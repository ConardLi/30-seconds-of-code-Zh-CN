[![Logo](/logo.png)](https://github.com/ConardLi/30-seconds-of-code-Zh-CN)

# 30-seconds-of-code-Zh-CN

> ä½ å¯ä»¥åœ¨30ç§’æˆ–æ›´çŸ­çš„æ—¶é—´å†…ç†è§£çš„æœ‰ç”¨çš„javascriptç‰‡æ®µçš„ç²¾é€‰é›†ã€‚

* ä½¿ç”¨ <kbd>Ctrl</kbd> + <kbd>F</kbd> or <kbd>command</kbd> + <kbd>F</kbd> æ¥æœç´¢ä¸€ä¸ªç‰‡æ®µ.
* æ‚¨å¯ä»¥åœ¨æœ¬é¡µé¢å…¨è§ˆæ‰€æœ‰ä»£ç ï¼Œä¹Ÿå¯ä»¥ç‚¹å‡»ä¸‹é¢çš„ç›®å½•åˆ°å¯¹åº”çš„å­ç•Œé¢ã€‚

## ç›®å½•

### ğŸ”Œ [Adapter](/Adapter.md)

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`ary`](/Adapter.md#ary)
* [`call`](/Adapter.md#call)
* [`collectInto`](/Adapter.md#collectinto)
* [`flip`](/Adapter.md#flip)
* [`over`](/Adapter.md#over)
* [`overArgs`](/Adapter.md#overargs)
* [`pipeAsyncFunctions`](/Adapter.md#pipeasyncfunctions)
* [`pipeFunctions`](/Adapter.md#pipefunctions)
* [`promisify`](/Adapter.md#promisify)
* [`rearg`](/Adapter.md#rearg)
* [`spreadOver`](/Adapter.md#spreadover)
* [`unary`](/Adapter.md#unary)

</details>

### ğŸ“š [Array](/Array.md)

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`all`](#all)
* [`allEqual`](#allequal)
* [`any`](#any)
* [`arrayToCSV`](#arraytocsv)
* [`bifurcate`](#bifurcate)
* [`bifurcateBy`](#bifurcateby)
* [`chunk`](#chunk)
* [`compact`](#compact)
* [`countBy`](#countby)
* [`countOccurrences`](#countoccurrences)
* [`deepFlatten`](#deepflatten)
* [`difference`](#difference)
* [`differenceBy`](#differenceby)
* [`differenceWith`](#differencewith)
* [`drop`](#drop)
* [`dropRight`](#dropright)
* [`dropRightWhile`](#droprightwhile)
* [`dropWhile`](#dropwhile)
* [`everyNth`](#everynth)
* [`filterFalsy`](#filterfalsy)
* [`filterNonUnique`](#filternonunique)
* [`filterNonUniqueBy`](#filternonuniqueby)
* [`findLast`](#findlast)
* [`findLastIndex`](#findlastindex)
* [`flatten`](#flatten)
* [`forEachRight`](#foreachright)
* [`groupBy`](#groupby)
* [`head`](#head)
* [`indexOfAll`](#indexofall)
* [`initial`](#initial)
* [`initialize2DArray`](#initialize2darray)
* [`initializeArrayWithRange`](#initializearraywithrange)
* [`initializeArrayWithRangeRight`](#initializearraywithrangeright)
* [`initializeArrayWithValues`](#initializearraywithvalues)
* [`initializeNDArray`](#initializendarray)
* [`intersection`](#intersection)
* [`intersectionBy`](#intersectionby)
* [`intersectionWith`](#intersectionwith)
* [`isSorted`](#issorted)
* [`join`](#join)
* [`JSONtoCSV`](#jsontocsv-)
* [`last`](#last)
* [`longestItem`](#longestitem)
* [`mapObject`](#mapobject-)
* [`maxN`](#maxn)
* [`minN`](#minn)
* [`none`](#none)
* [`nthElement`](#nthelement)
* [`offset`](#offset)
* [`partition`](#partition)
* [`permutations`](#permutations-)
* [`pull`](#pull)
* [`pullAtIndex`](#pullatindex-)
* [`pullAtValue`](#pullatvalue-)
* [`pullBy`](#pullby-)
* [`reducedFilter`](#reducedfilter)
* [`reduceSuccessive`](#reducesuccessive)
* [`reduceWhich`](#reducewhich)
* [`reject`](#reject)
* [`remove`](#remove)
* [`sample`](#sample)
* [`sampleSize`](#samplesize)
* [`shank`](#shank)
* [`shuffle`](#shuffle)
* [`similarity`](#similarity)
* [`sortedIndex`](#sortedindex)
* [`sortedIndexBy`](#sortedindexby)
* [`sortedLastIndex`](#sortedlastindex)
* [`sortedLastIndexBy`](#sortedlastindexby)
* [`stableSort`](#stablesort-)
* [`symmetricDifference`](#symmetricdifference)
* [`symmetricDifferenceBy`](#symmetricdifferenceby)
* [`symmetricDifferenceWith`](#symmetricdifferencewith)
* [`tail`](#tail)
* [`take`](#take)
* [`takeRight`](#takeright)
* [`takeRightWhile`](#takerightwhile)
* [`takeWhile`](#takewhile)
* [`toHash`](#tohash)
* [`union`](#union)
* [`unionBy`](#unionby)
* [`unionWith`](#unionwith)
* [`uniqueElements`](#uniqueelements)
* [`uniqueElementsBy`](#uniqueelementsby)
* [`uniqueElementsByRight`](#uniqueelementsbyright)
* [`uniqueSymmetricDifference`](#uniquesymmetricdifference)
* [`unzip`](#unzip)
* [`unzipWith`](#unzipwith-)
* [`without`](#without)
* [`xProd`](#xprod)
* [`zip`](#zip)
* [`zipObject`](#zipobject)
* [`zipWith`](#zipwith-)

</details>

### ğŸŒ Browser

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`arrayToHtmlList`](#arraytohtmllist)
* [`bottomVisible`](#bottomvisible)
* [`copyToClipboard`](#copytoclipboard-)
* [`counter`](#counter-)
* [`createElement`](#createelement)
* [`createEventHub`](#createeventhub-)
* [`currentURL`](#currenturl)
* [`detectDeviceType`](#detectdevicetype)
* [`elementContains`](#elementcontains)
* [`elementIsVisibleInViewport`](#elementisvisibleinviewport-)
* [`getImages`](#getimages)
* [`getScrollPosition`](#getscrollposition)
* [`getStyle`](#getstyle)
* [`hasClass`](#hasclass)
* [`hashBrowser`](#hashbrowser-)
* [`hide`](#hide)
* [`httpsRedirect`](#httpsredirect)
* [`insertAfter`](#insertafter)
* [`insertBefore`](#insertbefore)
* [`isBrowserTabFocused`](#isbrowsertabfocused)
* [`nodeListToArray`](#nodelisttoarray)
* [`observeMutations`](#observemutations-)
* [`off`](#off)
* [`on`](#on)
* [`onUserInputChange`](#onuserinputchange-)
* [`prefix`](#prefix)
* [`recordAnimationFrames`](#recordanimationframes)
* [`redirect`](#redirect)
* [`runAsync`](#runasync-)
* [`scrollToTop`](#scrolltotop)
* [`setStyle`](#setstyle)
* [`show`](#show)
* [`smoothScroll`](#smoothscroll)
* [`toggleClass`](#toggleclass)
* [`triggerEvent`](#triggerevent)
* [`UUIDGeneratorBrowser`](#uuidgeneratorbrowser)

</details>

### â±ï¸ Date

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`dayOfYear`](#dayofyear)
* [`formatDuration`](#formatduration)
* [`getColonTimeFromDate`](#getcolontimefromdate)
* [`getDaysDiffBetweenDates`](#getdaysdiffbetweendates)
* [`getMeridiemSuffixOfInteger`](#getmeridiemsuffixofinteger)
* [`isAfterDate`](#isafterdate)
* [`isBeforeDate`](#isbeforedate)
* [`isSameDate`](#issamedate)
* [`maxDate`](#maxdate)
* [`minDate`](#mindate)
* [`tomorrow`](#tomorrow)

</details>

### ğŸ›ï¸ Function

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`attempt`](#attempt)
* [`bind`](#bind)
* [`bindKey`](#bindkey)
* [`chainAsync`](#chainasync)
* [`compose`](#compose)
* [`composeRight`](#composeright)
* [`converge`](#converge)
* [`curry`](#curry)
* [`debounce`](#debounce)
* [`defer`](#defer)
* [`delay`](#delay)
* [`functionName`](#functionname)
* [`hz`](#hz)
* [`memoize`](#memoize-)
* [`negate`](#negate)
* [`once`](#once)
* [`partial`](#partial)
* [`partialRight`](#partialright)
* [`runPromisesInSeries`](#runpromisesinseries)
* [`sleep`](#sleep)
* [`throttle`](#throttle-)
* [`times`](#times)
* [`uncurry`](#uncurry)
* [`unfold`](#unfold)
* [`when`](#when)

</details>

### â— Math

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`approximatelyEqual`](#approximatelyequal)
* [`average`](#average)
* [`averageBy`](#averageby)
* [`binomialCoefficient`](#binomialcoefficient)
* [`clampNumber`](#clampnumber)
* [`degreesToRads`](#degreestorads)
* [`digitize`](#digitize)
* [`distance`](#distance)
* [`elo`](#elo-)
* [`factorial`](#factorial)
* [`fibonacci`](#fibonacci)
* [`gcd`](#gcd)
* [`geometricProgression`](#geometricprogression)
* [`hammingDistance`](#hammingdistance)
* [`inRange`](#inrange)
* [`isDivisible`](#isdivisible)
* [`isEven`](#iseven)
* [`isNegativeZero`](#isnegativezero)
* [`isPrime`](#isprime)
* [`lcm`](#lcm)
* [`luhnCheck`](#luhncheck-)
* [`maxBy`](#maxby)
* [`median`](#median)
* [`midpoint`](#midpoint)
* [`minBy`](#minby)
* [`percentile`](#percentile)
* [`powerset`](#powerset)
* [`primes`](#primes)
* [`radsToDegrees`](#radstodegrees)
* [`randomIntArrayInRange`](#randomintarrayinrange)
* [`randomIntegerInRange`](#randomintegerinrange)
* [`randomNumberInRange`](#randomnumberinrange)
* [`round`](#round)
* [`sdbm`](#sdbm)
* [`standardDeviation`](#standarddeviation)
* [`sum`](#sum)
* [`sumBy`](#sumby)
* [`sumPower`](#sumpower)
* [`toSafeInteger`](#tosafeinteger)

</details>

### ğŸ“¦ Node

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`atob`](#atob)
* [`btoa`](#btoa)
* [`colorize`](#colorize)
* [`createDirIfNotExists`](#createdirifnotexists)
* [`hasFlags`](#hasflags)
* [`hashNode`](#hashnode)
* [`isDuplexStream`](#isduplexstream)
* [`isReadableStream`](#isreadablestream)
* [`isStream`](#isstream)
* [`isTravisCI`](#istravisci)
* [`isWritableStream`](#iswritablestream)
* [`JSONToFile`](#jsontofile)
* [`readFileLines`](#readfilelines)
* [`untildify`](#untildify)
* [`UUIDGeneratorNode`](#uuidgeneratornode)

</details>

### ğŸ—ƒï¸ Object

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`bindAll`](#bindall)
* [`deepClone`](#deepclone)
* [`deepFreeze`](#deepfreeze)
* [`deepMapKeys`](#deepmapkeys-)
* [`defaults`](#defaults)
* [`dig`](#dig)
* [`equals`](#equals-)
* [`findKey`](#findkey)
* [`findLastKey`](#findlastkey)
* [`flattenObject`](#flattenobject)
* [`forOwn`](#forown)
* [`forOwnRight`](#forownright)
* [`functions`](#functions)
* [`get`](#get)
* [`invertKeyValues`](#invertkeyvalues)
* [`lowercaseKeys`](#lowercasekeys)
* [`mapKeys`](#mapkeys)
* [`mapValues`](#mapvalues)
* [`matches`](#matches)
* [`matchesWith`](#matcheswith)
* [`merge`](#merge)
* [`nest`](#nest)
* [`objectFromPairs`](#objectfrompairs)
* [`objectToPairs`](#objecttopairs)
* [`omit`](#omit)
* [`omitBy`](#omitby)
* [`orderBy`](#orderby)
* [`pick`](#pick)
* [`pickBy`](#pickby)
* [`renameKeys`](#renamekeys)
* [`shallowClone`](#shallowclone)
* [`size`](#size)
* [`transform`](#transform)
* [`truthCheckCollection`](#truthcheckcollection)
* [`unflattenObject`](#unflattenobject-)

</details>

### ğŸ“œ String

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`byteSize`](#bytesize)
* [`capitalize`](#capitalize)
* [`capitalizeEveryWord`](#capitalizeeveryword)
* [`compactWhitespace`](#compactwhitespace)
* [`CSVToArray`](#csvtoarray)
* [`CSVToJSON`](#csvtojson-)
* [`decapitalize`](#decapitalize)
* [`escapeHTML`](#escapehtml)
* [`escapeRegExp`](#escaperegexp)
* [`fromCamelCase`](#fromcamelcase)
* [`indentString`](#indentstring)
* [`isAbsoluteURL`](#isabsoluteurl)
* [`isAnagram`](#isanagram)
* [`isLowerCase`](#islowercase)
* [`isUpperCase`](#isuppercase)
* [`mapString`](#mapstring)
* [`mask`](#mask)
* [`pad`](#pad)
* [`palindrome`](#palindrome)
* [`pluralize`](#pluralize)
* [`removeNonASCII`](#removenonascii)
* [`reverseString`](#reversestring)
* [`sortCharactersInString`](#sortcharactersinstring)
* [`splitLines`](#splitlines)
* [`stringPermutations`](#stringpermutations-)
* [`stripHTMLTags`](#striphtmltags)
* [`toCamelCase`](#tocamelcase)
* [`toKebabCase`](#tokebabcase)
* [`toSnakeCase`](#tosnakecase)
* [`toTitleCase`](#totitlecase)
* [`truncateString`](#truncatestring)
* [`unescapeHTML`](#unescapehtml)
* [`URLJoin`](#urljoin-)
* [`words`](#words)

</details>

### ğŸ“ƒ Type

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`getType`](#gettype)
* [`is`](#is)
* [`isArrayLike`](#isarraylike)
* [`isBoolean`](#isboolean)
* [`isEmpty`](#isempty)
* [`isFunction`](#isfunction)
* [`isNil`](#isnil)
* [`isNull`](#isnull)
* [`isNumber`](#isnumber)
* [`isObject`](#isobject)
* [`isObjectLike`](#isobjectlike)
* [`isPlainObject`](#isplainobject)
* [`isPrimitive`](#isprimitive)
* [`isPromiseLike`](#ispromiselike)
* [`isString`](#isstring)
* [`isSymbol`](#issymbol)
* [`isUndefined`](#isundefined)
* [`isValidJSON`](#isvalidjson)

</details>

### ğŸ”§ Utility

<details>
<summary>æŸ¥çœ‹ç›®å½•</summary>

* [`castArray`](#castarray)
* [`cloneRegExp`](#cloneregexp)
* [`coalesce`](#coalesce)
* [`coalesceFactory`](#coalescefactory)
* [`extendHex`](#extendhex)
* [`getURLParameters`](#geturlparameters)
* [`hexToRGB`](#hextorgb-)
* [`httpGet`](#httpget)
* [`httpPost`](#httppost)
* [`isBrowser`](#isbrowser)
* [`mostPerformant`](#mostperformant)
* [`nthArg`](#ntharg)
* [`parseCookie`](#parsecookie)
* [`prettyBytes`](#prettybytes-)
* [`randomHexColorCode`](#randomhexcolorcode)
* [`RGBToHex`](#rgbtohex)
* [`serializeCookie`](#serializecookie)
* [`timeTaken`](#timetaken)
* [`toCurrency`](#tocurrency)
* [`toDecimalMark`](#todecimalmark)
* [`toOrdinalSuffix`](#toordinalsuffix)
* [`validateNumber`](#validatenumber)
* [`yesNo`](#yesno)

</details>


---

## ğŸ”Œ Adapter

### ary

åˆ›å»ºä¸€ä¸ªå¯ä»¥æ¥æ”¶nä¸ªå‚æ•°çš„å‡½æ•°, å¿½ç•¥å…¶ä»–é¢å¤–çš„å‚æ•°ã€‚

è°ƒç”¨æä¾›çš„å‡½æ•°`fn`,å‚æ•°æœ€å¤šä¸ºnä¸ª, ä½¿ç”¨ `Array.prototype.slice(0,n)` å’Œå±•å¼€æ“ä½œç¬¦ (`...`)ã€‚

```js
const ary = (fn, n) => (...args) => fn(...args.slice(0, n));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const firstTwoMax = ary(Math.max, 2);
[[2, 6, 'a'], [8, 4, 6], [10]].map(x => firstTwoMax(...x)); // [6, 8, 10]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### call

ç»™å®šä¸€ä¸ªkeyå’Œä¸€ç»„å‚æ•°ï¼Œç»™å®šä¸€ä¸ªä¸Šä¸‹æ–‡æ—¶è°ƒç”¨å®ƒä»¬ã€‚ä¸»è¦ç”¨äºåˆå¹¶ã€‚

ä½¿ç”¨é—­åŒ…è°ƒç”¨ä¸Šä¸‹æ–‡ä¸­keyå¯¹åº”çš„å€¼ï¼Œå³å¸¦æœ‰å­˜å‚¨å‚æ•°çš„å‡½æ•°ã€‚

```js
const call = (key, ...args) => context => context[key](...args);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
Promise.resolve([1, 2, 3])
  .then(call('map', x => 2 * x))
  .then(console.log); // [ 2, 4, 6 ]
const map = call.bind(null, 'map');
Promise.resolve([1, 2, 3])
  .then(map(x => 2 * x))
  .then(console.log); // [ 2, 4, 6 ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### collectInto

å°†ä¸€ä¸ªæ¥æ”¶æ•°ç»„å‚æ•°çš„å‡½æ•°æ”¹å˜ä¸ºå¯å˜å‚æ•°çš„å‡½æ•°ã€‚

ç»™å®šä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œè¯¥é—­åŒ…å°†æ‰€æœ‰è¾“å…¥æ”¶é›†åˆ°ä¸€ä¸ªæ•°ç»„æ¥å—å‡½æ•°ä¸­ã€‚

```js
const collectInto = fn => (...args) => fn(args);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const Pall = collectInto(Promise.all.bind(Promise));
let p1 = Promise.resolve(1);
let p2 = Promise.resolve(2);
let p3 = new Promise(resolve => setTimeout(resolve, 2000, 3));
Pall(p1, p2, p3).then(console.log); // [1, 2, 3] (after about 2 seconds)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### flip

Flipä»¥ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œç„¶åæŠŠç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºæœ€åä¸€ä¸ªå‚æ•°ã€‚

è¿”å›ä¸€ä¸ªå¯å˜å‚æ•°çš„é—­åŒ…ï¼Œåœ¨åº”ç”¨å…¶ä»–å‚æ•°å‰ï¼Œå…ˆæŠŠç¬¬ä¸€ä¸ªä»¥å¤–çš„å…¶ä»–å‚æ•°ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ã€‚


```js
const flip = fn => (first, ...rest) => fn(...rest, first);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
let a = { name: 'John Smith' };
let b = {};
const mergeFrom = flip(Object.assign);
let mergePerson = mergeFrom.bind(null, a);
mergePerson(b); // == b
b = {};
Object.assign(b, a); // == b
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### over

åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å¯ä»¥è°ƒç”¨æ¯ä¸€ä¸ªè¢«ä¼ å…¥çš„å¹¶ä¸”æ‰æœ‰å‚æ•°çš„å‡½æ•°ï¼Œç„¶åè¿”å›ç»“æœã€‚

ä½¿ç”¨ `Array.prototype.map()` å’Œ `Function.prototype.apply()`å°†æ¯ä¸ªå‡½æ•°åº”ç”¨ç»™å®šçš„å‚æ•°ã€‚

```js
const over = (...fns) => (...args) => fns.map(fn => fn.apply(null, args));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const minMax = over(Math.min, Math.max);
minMax(1, 2, 3, 4, 5); // [1,5]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### overArgs

åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå®ƒå¯ä»¥è°ƒç”¨æä¾›çš„è¢«è½¬æ¢å‚æ•°çš„å‡½æ•°ã€‚

ä½¿ç”¨`Array.prototype.map()`å°†`transforms`åº”ç”¨äº`args`ï¼Œå¹¶ç»“åˆæ‰©å±•è¿ç®—ç¬¦(`â€¦`)å°†è½¬æ¢åçš„å‚æ•°ä¼ é€’ç»™`fn`ã€‚


```js
const overArgs = (fn, transforms) => (...args) => fn(...args.map((val, i) => transforms[i](val)));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const square = n => n * n;
const double = n => n * 2;
const fn = overArgs((x, y) => [x, y], [square, double]);
fn(9, 3); // [81, 6]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### pipeAsyncFunctions

ä¸ºå¼‚æ­¥å‡½æ•°æ‰§è¡Œä»å·¦åˆ°å³çš„å‡½æ•°ç»„åˆã€‚

åœ¨æ‰©å±•æ“ä½œç¬¦(`â€¦`)ä¸­ä½¿ç”¨`Array.prototype.reduce() `æ¥ä½¿ç”¨`Promise.then()`æ‰§è¡Œä»å·¦åˆ°å³çš„å‡½æ•°ç»„åˆã€‚
è¿™äº›å‡½æ•°å¯ä»¥è¿”å›ç®€å•å€¼ã€`Promise`çš„ç»„åˆï¼Œä¹Ÿå¯ä»¥å®šä¹‰ä¸ºé€šè¿‡`await`è¿”å›çš„`async`å€¼ã€‚
æ‰€æœ‰å‡½æ•°å¿…é¡»æ˜¯ä¸€å…ƒçš„ã€‚

```js
const pipeAsyncFunctions = (...fns) => arg => fns.reduce((p, f) => p.then(f), Promise.resolve(arg));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js

const sum = pipeAsyncFunctions(
  x => x + 1,
  x => new Promise(resolve => setTimeout(() => resolve(x + 2), 1000)),
  x => x + 3,
  async x => (await x) + 4
);
(async() => {
  console.log(await sum(5)); // 15 (after one second)
})();
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### pipeFunctions

æ‰§è¡Œä»å·¦åˆ°å³çš„å‡½æ•°ç»„åˆã€‚

åœ¨å±•å¼€æ“ä½œç¬¦(`â€¦`)ä¸­ä½¿ç”¨`Array.prototype.reduce()`æ¥æ‰§è¡Œä»å·¦åˆ°å³çš„å‡½æ•°ç»„åˆã€‚
ç¬¬ä¸€ä¸ª(æœ€å·¦è¾¹çš„)å‡½æ•°å¯ä»¥æ¥å—ä¸€ä¸ªæˆ–å¤šä¸ªå‚æ•°; å…¶ä½™çš„å‡½æ•°å¿…é¡»æ˜¯ä¸€å…ƒçš„ã€‚

```js
const pipeFunctions = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const add5 = x => x + 5;
const multiply = (x, y) => x * y;
const multiplyAndAdd5 = pipeFunctions(multiply, add5);
multiplyAndAdd5(5, 2); // 15
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### promisify

æŠŠä¸€ä¸ªå¼‚æ­¥å‡½æ•°è½¬æ¢æˆè¿”å›promiseçš„ã€‚

ä½¿ç”¨å±€éƒ¨å¥—ç”¨è¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°è¿”å›ä¸€ä¸ªè°ƒç”¨åŸå§‹å‡½æ•°çš„`Promise`ã€‚
ä½¿ç”¨çš„`...`æ“ä½œç¬¦æ¥ä¼ å…¥æ‰€æœ‰å‚æ•°ã€‚

```js
const promisify = func => (...args) =>
  new Promise((resolve, reject) =>
    func(...args, (err, result) => (err ? reject(err) : resolve(result)))
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const delay = promisify((d, cb) => setTimeout(cb, d));
delay(2000).then(() => console.log('Hi!')); // // Promise resolves after 2s
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### rearg

åˆ›å»ºä¸€ä¸ªè°ƒç”¨æä¾›çš„å‡½æ•°çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°çš„å‚æ•°æŒ‰ç…§æŒ‡å®šçš„ç´¢å¼•æ’åˆ—ã€‚

åˆ©ç”¨ `Array.prototype.map()` æ ¹æ® `indexes` å’Œå±•å¼€æ“ä½œç¬¦ (`...`) å¯¹å‚æ•°è¿›è¡Œé‡æ–°æ’åºï¼Œå°†è½¬æ¢åçš„å‚æ•°ä¼ é€’ç»™ `fn`ã€‚

```js
const rearg = (fn, indexes) => (...args) => fn(...indexes.map(i => args[i]));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
var rearged = rearg(
  function(a, b, c) {
    return [a, b, c];
  },
  [2, 0, 1]
);
rearged('b', 'c', 'a'); // ['a', 'b', 'c']
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### spreadOver

æ¥å—ä¸€ä¸ªå¯å˜å‚æ•°å‡½æ•°å¹¶è¿”å›ä¸€ä¸ªé—­åŒ…ï¼Œè¯¥é—­åŒ…æ¥å—ä¸€ä¸ªå‚æ•°æ•°ç»„ä»¥æ˜ å°„åˆ°å‡½æ•°çš„è¾“å…¥ã€‚

ä½¿ç”¨é—­åŒ…å’Œæ‰©å±•æ“ä½œç¬¦(`â€¦`)å°†å‚æ•°æ•°ç»„æ˜ å°„åˆ°å‡½æ•°çš„è¾“å…¥ã€‚

```js
const spreadOver = fn => argsArr => fn(...argsArr);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const arrayMax = spreadOver(Math.max);
arrayMax([1, 2, 3]); // 3
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### unary

åˆ›å»ºä¸€ä¸ªæœ€å¤šæ¥å—ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼Œå¿½ç•¥ä»»ä½•å…¶ä»–å‚æ•°ã€‚

åªæŠŠç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ç»™è¦è°ƒç”¨çš„å‡½æ•°`fn`ã€‚

```js
const unary = fn => val => fn(val);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
['6', '8', '10'].map(unary(parseInt)); // [6, 8, 10]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)


---

## ğŸ“š Array

### all

å¦‚æœè¢«æä¾›çš„æ–­è¨€å‡½æ•°æ¥æ”¶æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ ä½œä¸ºå‚æ•°éƒ½è¿”å›`true`ï¼Œåˆ™è¿”å›`true`ï¼Œå¦åˆ™è¿”å›`false`ã€‚


ä½¿ç”¨ `Array.prototype.every()`æ¥æµ‹è¯•æ˜¯å¦ç¬¬äºŒä¸ªå‚æ•°`fn`ä»¥é›†åˆä¸­æ¯ä¸ªå…ƒç´ ä½œä¸ºå‚æ•°éƒ½è¿”å›`true`ï¼Œä½¿ç”¨`Boolean`ä½œä¸ºé»˜è®¤å€¼ã€‚

```js
const all = (arr, fn = Boolean) => arr.every(fn);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
all([4, 2, 3], x => x > 1); // true
all([1, 2, 3]); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### allEqual

æ£€æŸ¥æ˜¯å¦æ•°ç»„ä¸­æ‰€æœ‰çš„å…ƒç´ éƒ½æ˜¯ç›¸ç­‰çš„ã€‚

ä½¿ç”¨ `Array.prototype.every()` æ¥æ£€æµ‹æ˜¯å¦æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å’Œç¬¬ä¸€ä¸ªå…ƒç´ ç›¸ç­‰ã€‚

```js
const allEqual = arr => arr.every(val => val === arr[0]);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
allEqual([1, 2, 3, 4, 5, 6]); // false
allEqual([1, 1, 1, 1]); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### any

å¦‚æœè¢«æä¾›çš„æ–­è¨€å‡½æ•°æ¥æ”¶æ•°ç»„ä¸­ä»»æ„ä¸€ä¸ªå…ƒç´ ä½œä¸ºå‚æ•°éƒ½è¿”å›`true`ï¼Œåˆ™è¿”å›`true`ï¼Œå¦åˆ™è¿”å›`false`ã€‚

ä½¿ç”¨ `Array.prototype.every()`æ¥æµ‹è¯•æ˜¯å¦ç¬¬äºŒä¸ªå‚æ•°`fn`ä»¥é›†åˆä¸­ä»»æ„ä¸€ä¸ªå…ƒç´ ä½œä¸ºå‚æ•°éƒ½è¿”å›`true`ï¼Œä½¿ç”¨`Boolean`ä½œä¸ºé»˜è®¤å€¼ã€‚

```js
const any = (arr, fn = Boolean) => arr.some(fn);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
any([0, 1, 2, 0], x => x >= 2); // true
any([0, 0, 1, 0]); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### arrayToCSV

å°†2Dæ•°ç»„è½¬æ¢ä¸ºé€—å·åˆ†éš”å€¼(CSV)å­—ç¬¦ä¸²ã€‚

ä½¿ç”¨ `Array.prototype.map()` å’Œ `Array.prototype.join(delimiter)` å°†ä¸€ä¸ªä¸€ç»´æ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚

ä½¿ç”¨ `Array.prototype.join('\n')` å°†æ‰€æœ‰è¡Œåˆå¹¶æˆCSVå­—ç¬¦ä¸², ç”¨æ¢è¡Œç¬¦åˆ†å‰²æ¯ä¸€è¡Œã€‚

å¦‚æœæ²¡æœ‰ç¬¬äºŒå“¥å‚æ•°, `delimiter`ä¼šä½¿ç”¨ä¸€ä¸ªé»˜è®¤åˆ†éš”ç¬¦ `,`.

```js
const arrayToCSV = (arr, delimiter = ',') =>
  arr.map(v => v.map(x => `"${x}"`).join(delimiter)).join('\n');
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
arrayToCSV([['a', 'b'], ['c', 'd']]); // '"a","b"\n"c","d"'
arrayToCSV([['a', 'b'], ['c', 'd']], ';'); // '"a";"b"\n"c";"d"'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### bifurcate

å°†æ•°æ®åˆ†ä¸ºä¸¤ç»„ï¼Œå¦‚æœå…ƒç´ åœ¨ `filter`æ•°ç»„ä¸­å¯¹åº”çš„æ˜¯`true`ï¼Œé›†åˆä¸­ç›¸åº”çš„å…ƒç´ åº”åŠ å…¥ç¬¬ä¸€ä¸ªæ•°ç»„ï¼Œå¦åˆ™åŠ å…¥ç¬¬äºŒä¸ªæ•°ç»„ã€‚

åŸºäº`filter`ä½¿ç”¨`Array.prototype.reduce()` å’Œ `Array.prototype.push()`å°†å…ƒç´ åˆ†ç»„ã€‚

```js
const bifurcate = (arr, filter) =>
  arr.reduce((acc, val, i) => (acc[filter[i] ? 0 : 1].push(val), acc), [[], []]);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
bifurcate(['beep', 'boop', 'foo', 'bar'], [true, true, false, true]); // [ ['beep', 'boop', 'bar'], ['foo'] ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### bifurcateBy

æ ¹æ®æ–­è¨€å‡½æ•°å°†æ•°æ®åˆ†æˆä¸¤ç»„ï¼Œæ–­è¨€å‡½æ•°å°†æŒ‡å®šé›†åˆä¸­çš„å…ƒç´ å±äºå“ªä¸ªç»„ã€‚å¦‚æœæ–­è¨€å‡½æ•°è¿”å›`true`ï¼Œå…ƒç´ åŠ å…¥ç¬¬ä¸€ä¸ªæ•°ç»„ï¼Œå¦åˆ™åŠ å…¥ç¬¬äºŒä¸ªæ•°ç»„ã€‚

ç»™äºˆ`fn`æ¥æ”¶å…ƒç´ çš„è¿”å›å€¼ï¼Œä½¿ç”¨`Array.prototype.reduce()` å’Œ `Array.prototype.push()`å°†å…ƒç´ åˆ†ç»„ã€‚

```js
const bifurcateBy = (arr, fn) =>
  arr.reduce((acc, val, i) => (acc[fn(val, i) ? 0 : 1].push(val), acc), [[], []]);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
bifurcateBy(['beep', 'boop', 'foo', 'bar'], x => x[0] === 'b'); // [ ['beep', 'boop', 'bar'], ['foo'] ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### chunk

å°†æ•°ç»„åˆ†æˆæŒ‡å®šå¤§å°çš„è¾ƒå°æ•°ç»„ã€‚

ä½¿ç”¨ `Array.from()`åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„ï¼Œè¯¥æ•°ç»„ä¸å°†è¦ç”Ÿæˆçš„å—çš„æ•°é‡ç›¸åŒ¹é…ã€‚
ä½¿ç”¨ `Array.prototype.slice()` å°†æ–°æ•°ç»„çš„æ¯ä¸ªå…ƒç´ æ˜ å°„åˆ°é•¿åº¦ä¸º`size`çš„å—ã€‚
å¦‚æœåŸå§‹çš„æ•°ç»„ä¸èƒ½è¢«å‡åŒ€çš„åˆ†å‰²ï¼Œæœ€åçš„ä¸€å—å°†åŒ…å«å‰©ä½™çš„å…ƒç´ ã€‚


```js
const chunk = (arr, size) =>
  Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>
    arr.slice(i * size, i * size + size)
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
chunk([1, 2, 3, 4, 5], 2); // [[1,2],[3,4],[5]]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### compact

åˆ é™¤æ•°ç»„ä¸­é”™è¯¯çš„å…ƒç´ 

ä½¿ç”¨ `Array.prototype.filter()` è¿‡æ»¤æ‰é”™è¯¯çš„å…ƒç´  (`false`, `null`, `0`, `""`, `undefined`,  `NaN`).

```js
const compact = arr => arr.filter(Boolean);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]); // [ 1, 2, 3, 'a', 's', 34 ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### countBy

åŸºäºç»™å®šçš„å‡½æ•°å°†æ•°ç»„ä¸­çš„å…ƒç´ è¿›è¡Œåˆ†ç»„ï¼Œå¹¶è¿”å›æ¯ä¸ªç»„ä¸­çš„å…ƒç´ æ•°ã€‚

ä½¿ç”¨`Array.prototype.map()`æ¥å°†æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜ å°„åˆ°å‡½æ•°æˆ–å±æ€§åã€‚
ä½¿ç”¨ `Array.prototype.reduce()` åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­çš„é”®æ˜¯ä»æ˜ å°„ç»“æœç”Ÿæˆçš„ã€‚


```js
const countBy = (arr, fn) =>
  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => {
    acc[val] = (acc[val] || 0) + 1;
    return acc;
  }, {});
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
countBy([6.1, 4.2, 6.3], Math.floor); // {4: 1, 6: 2}
countBy(['one', 'two', 'three'], 'length'); // {3: 2, 5: 1}
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### countOccurrences

è®¡ç®—æ•°ç»„ä¸­æŸä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ã€‚

Use `Array.prototype.reduce()`åœ¨æ¯æ¬¡é‡åˆ°æ•°ç»„ä¸­çš„ç‰¹å®šå€¼æ—¶é€’å¢è®¡æ•°å™¨ã€‚
```js
const countOccurrences = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
countOccurrences([1, 1, 2, 1, 2, 3], 1); // 3
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### deepFlatten

å°†ä¸€ä¸ªå¤šå±‚åµŒå¥—çš„æ•°ç»„è½¬è½¬æ¢æˆä¸€ä¸ªä¸€å…ƒæ•°ç»„ã€‚

ä½¿ç”¨é€’å½’.
Use `Array.prototype.concat()` with an empty array (`[]`) and the spread operator (`...`) to flatten an array.
ä½¿ç”¨ `Array.prototype.concat()` å’Œä¸€ä¸ªç©ºæ•°ç»„(`[]`)ä»¥åŠå±•å¼€è¿ç®—ç¬¦(`...`)æ¥å¹³é“ºä¸€ä¸ªæ•°ç»„ã€‚
å½“æ¯ä¸ªå…ƒç´ è¿˜æ˜¯ä¸€ä¸ªæ•°å­—æ—¶ï¼Œé€’å½’é“ºå¹³ä»–ã€‚

```js
const deepFlatten = arr => [].concat(...arr.map(v => (Array.isArray(v) ? deepFlatten(v) : v)));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
deepFlatten([1, [2], [[3], 4], 5]); // [1,2,3,4,5]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### difference

è¿”å›ä¸¤ä¸ªæ•°ç»„é—´çš„å·®å¼‚å€¼ã€‚

ä»æ•°ç»„`b`ä¸­åˆ›å»ºä¸€ä¸ª `Set` ï¼Œç„¶åç”¨ä½¿ç”¨å¦ä¸€ä¸ªæ•°ç»„`a`çš„`Array.prototype.filter()` æ–¹æ³•è¿‡æ»¤æ‰`b`ä¸­çš„å…ƒç´ ã€‚

```js
const difference = (a, b) => {
  const s = new Set(b);
  return a.filter(x => !s.has(x));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
difference([1, 2, 3], [1, 2, 4]); // [3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### differenceBy

å°†æä¾›çš„å‡½æ•°åº”ç”¨äºä¸¤ä¸ªæ•°ç»„çš„æ¯ä¸ªæ•°ç»„å…ƒç´ åï¼Œè¿”å›ä¸¤ä¸ªæ•°ç»„ä¸­ä¸åŒçš„å…ƒç´ ã€‚

é€šè¿‡`b`ä¸­çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨ `fn`ååˆ›å»ºä¸€ä¸ª `Set` ï¼Œç„¶åå°†`Array.prototype.filter()` ä¸`fn`è°ƒç”¨åçš„`a`ç»“åˆä½¿ç”¨ï¼Œåªä¿ç•™å…ˆå‰åˆ›å»ºçš„é›†åˆä¸­ä¸åŒ…å«çš„å€¼ã€‚


```js
const differenceBy = (a, b, fn) => {
  const s = new Set(b.map(fn));
  return a.filter(x => !s.has(fn(x)));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [1.2]
differenceBy([{ x: 2 }, { x: 1 }], [{ x: 1 }], v => v.x); // [ { x: 2 } ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### differenceWith

ç­›é€‰å‡ºæ¯”è¾ƒå™¨å‡½æ•°ä¸è¿”å›`true`çš„æ•°ç»„ä¸­çš„æ‰€æœ‰å€¼ã€‚

ä½¿ç”¨ `Array.prototype.filter()` å’Œ `Array.prototype.findIndex()` æŸ¥æ‰¾åˆé€‚çš„å€¼ã€‚

```js
const differenceWith = (arr, val, comp) => arr.filter(a => val.findIndex(b => comp(a, b)) === -1);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
differenceWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0], (a, b) => Math.round(a) === Math.round(b)); // [1, 1.2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### drop

è¿”å›ä¸€ä¸ªæ–°æ•°ç»„ï¼Œä»åŸæ•°ç»„å·¦è¾¹åˆ é™¤`n`ä¸ªå…ƒç´ ã€‚

ä½¿ç”¨ `Array.prototype.slice()` ä»å·¦ä¾§åˆ é™¤æŒ‡å®šæ•°é‡çš„å…ƒç´ ã€‚

```js
const drop = (arr, n = 1) => arr.slice(n);
```

> slice(n) è¡¨ç¤ºå–æ•°ç»„ä¸‹æ ‡nä»¥åçš„å…ƒç´ ï¼ˆå«nï¼‰

<details>
<summary>ç¤ºä¾‹</summary>

```js
drop([1, 2, 3]); // [2,3]
drop([1, 2, 3], 2); // [3]
drop([1, 2, 3], 42); // []
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### dropRight

è¿”å›ä¸€ä¸ªæ–°æ•°ç»„ï¼Œä»åŸæ•°ç»„å³è¾¹åˆ é™¤`n`ä¸ªå…ƒç´ ã€‚

ä½¿ç”¨ `Array.prototype.slice()`ä»å³è¾¹åˆ é™¤æŒ‡å®šæ•°ç›®çš„å…ƒç´ ã€‚

```js
const dropRight = (arr, n = 1) => arr.slice(0, -n);
```

> slice(0, -n) è¡¨ç¤ºå–æ•°ç»„ç¬¬ä¸€ä¸ªåˆ°å€’æ•°ç¬¬nä¸ªå…ƒç´ ï¼ˆä¸å«-nï¼‰


<details>
<summary>ç¤ºä¾‹</summary>

```js
dropRight([1, 2, 3]); // [1,2]
dropRight([1, 2, 3], 2); // [1]
dropRight([1, 2, 3], 42); // []
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### dropRightWhile

ä»æ•°ç»„å°¾éƒ¨ç§»é™¤æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œç›´åˆ°ä¼ é€’çš„å‡½æ•°è¿”å›`true`ã€‚è¿”å›æ•°ç»„ä¸­å‰©ä½™çš„å…ƒç´ ã€‚

éå†æ•°ç»„ï¼Œä½¿ç”¨`Array.prototype.slice()`åˆ é™¤æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°å‡½æ•°çš„è¿”å›å€¼ä¸º`true`ã€‚è¿”å›å‰©ä½™çš„å…ƒç´ ã€‚


```js
const dropRightWhile = (arr, func) => {
  while (arr.length > 0 && !func(arr[arr.length - 1])) arr = arr.slice(0, -1);
  return arr;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
dropRightWhile([1, 2, 3, 4], n => n < 3); // [1, 2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### dropWhile

ç§»é™¤æ•°ç»„ä¸­çš„å…ƒç´ ï¼Œç›´åˆ°ä¼ é€’çš„å‡½æ•°è¿”å›`true`ã€‚è¿”å›æ•°ç»„ä¸­å‰©ä½™çš„å…ƒç´ ã€‚

éå†æ•°ç»„ï¼Œä½¿ç”¨`Array.prototype.slice()`åˆ é™¤æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°å‡½æ•°çš„è¿”å›å€¼ä¸º`true`ã€‚è¿”å›å‰©ä½™çš„å…ƒç´ ã€‚

```js
const dropWhile = (arr, func) => {
  while (arr.length > 0 && !func(arr[0])) arr = arr.slice(1);
  return arr;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
dropWhile([1, 2, 3, 4], n => n >= 3); // [3,4]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### everyNth

è¿”å›æ•°ç»„ä¸­æ‰€æœ‰ä¸‹æ ‡æ˜¯nçš„å€æ•°çš„å…ƒç´ ã€‚

ä½¿ç”¨ `Array.prototype.filter()` åˆ›å»ºåŒ…å«ç»™å®šæ•°ç»„ä¸­æ‰€æœ‰ä¸‹æ ‡æ˜¯nçš„å€æ•°çš„å…ƒç´ çš„æ–°æ•°ç»„ã€‚

```js
const everyNth = (arr, nth) => arr.filter((e, i) => i % nth === nth - 1);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
everyNth([1, 2, 3, 4, 5, 6], 2); // [ 2, 4, 6 ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### filterFalsy

æŠŠæ•°ç»„ä¸­çš„`è™šå€¼`è¿‡æ»¤æ‰ã€‚

ä½¿ç”¨ `Array.prototype.filter()`åˆ›å»ºä¸€ä¸ªåªåŒ…å«`çœŸå€¼`çš„æ–°æ•°ç»„ã€‚ 


```js
const filterFalsy = arr => arr.filter(Boolean);
```

> `falsy`(è™šå€¼)æ˜¯åœ¨` Boolean `ä¸Šä¸‹æ–‡ä¸­å·²è®¤å®šå¯è½¬æ¢ä¸ºâ€˜å‡â€˜çš„å€¼ã€‚ä¾‹å¦‚ï¼šfalseï¼Œ0ï¼Œ""ï¼Œnullï¼Œundefined å’Œ NaN ã€‚

> `Truthy` (çœŸå€¼)æŒ‡çš„æ˜¯åœ¨ å¸ƒå°”å€¼ ä¸Šä¸‹æ–‡ä¸­è½¬æ¢åçš„å€¼ä¸ºçœŸçš„å€¼ã€‚æ‰€æœ‰å€¼éƒ½æ˜¯çœŸå€¼ï¼Œé™¤éå®ƒä»¬è¢«å®šä¹‰ä¸º `falsy`ã€‚


<details>
<summary>ç¤ºä¾‹</summary>

```js
filterFalsy(['', true, {}, false, 'sample', 1, 0]); // [true, {}, 'sample', 1]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### filterNonUnique

è¿‡æ»¤æ‰æ•°ç»„ä¸­é‡å¤çš„å€¼ã€‚

ä½¿ç”¨ `Array.prototype.filter()`åˆ›å»ºä¸€ä¸ªåªåŒ…å«è°“å”¯ä¸€å€¼çš„æ•°ç»„ã€‚


```js
const filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
filterNonUnique([1, 2, 2, 3, 4, 4, 5]); // [1, 3, 5]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### filterNonUniqueBy

åŸºäºç»™å®šçš„æ¯”è¾ƒå™¨å‡½æ•°ï¼Œè¿‡æ»¤æ‰æ•°ç»„ä¸­é‡å¤çš„å…ƒç´ ã€‚

ä½¿ç”¨`Array.prototype.filter()` å’Œ `Array.prototype.every()` åˆ›å»ºä¸€ä¸ªæ–°æ•°ç»„ï¼Œè¯¥æ•°ç»„åªåŒ…å«å”¯ä¸€å€¼ï¼ŒåŸºäºç»™å®šçš„æ¯”è¾ƒå™¨å‡½æ•° `fn`ã€‚

æ¯”è¾ƒå™¨å‡½æ•°æ¥æ”¶å››ä¸ªå‚æ•°ï¼šæ­£åœ¨è¢«æ¯”è¾ƒçš„ä¸¤ä¸ªå…ƒç´ å’Œä»–ä»¬çš„ç´¢å¼•ã€‚


```js
const filterNonUniqueBy = (arr, fn) =>
  arr.filter((v, i) => arr.every((x, j) => (i === j) === fn(v, x, i, j)));
```


<details>
<summary>ç¤ºä¾‹</summary>

```js
filterNonUniqueBy(
  [
    { id: 0, value: 'a' },
    { id: 1, value: 'b' },
    { id: 2, value: 'c' },
    { id: 1, value: 'd' },
    { id: 0, value: 'e' }
  ],
  (a, b) => a.id == b.id
); // [ { id: 2, value: 'c' } ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### findLast

è¿”å›æ‰€æä¾›å‡½æ•°è¿”å›`çœŸå€¼`çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚

ä½¿ç”¨ `Array.prototype.filter()` å°†è°ƒç”¨`fn`åè¿”å›`è™šå€¼`çš„å…ƒç´ è¿‡æ»¤æ‰, ç„¶åè°ƒç”¨`Array.prototype.pop()` æ¥è·å–æœ€åä¸€ä¸ªå…ƒç´ ã€‚

```js
const findLast = (arr, fn) => arr.filter(fn).pop();
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
findLast([1, 2, 3, 4], n => n % 2 === 1); // 3
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### findLastIndex

è¿”å›æ‰€æä¾›å‡½æ•°è¿”å›`çœŸå€¼`çš„æœ€åä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•ã€‚

ä½¿ç”¨ `Array.prototype.map()` å°†æ¯ä¸ªå…ƒç´ æ˜ å°„åˆ°å…·æœ‰å…¶ç´¢å¼•å’Œå€¼çš„æ•°ç»„ã€‚
ä½¿ç”¨ `Array.prototype.filter()` å°†è°ƒç”¨`fn`åè¿”å›`è™šå€¼`çš„å…ƒç´ è¿‡æ»¤æ‰, ç„¶åè°ƒç”¨`Array.prototype.pop()` æ¥è·å–æœ€åä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•ã€‚

```js
const findLastIndex = (arr, fn) =>
  arr
    .map((val, i) => [i, val])
    .filter(([i, val]) => fn(val, i, arr))
    .pop()[0];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
findLastIndex([1, 2, 3, 4], n => n % 2 === 1); // 2 (index of the value 3)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### flatten

æ ¹æ®æŒ‡å®šçš„æ·±åº¦å±•å¹³ä¸€ä¸ªæ•°ç»„ã€‚

ä½¿ç”¨é€’å½’ï¼Œæ¯å±‚é€’å½’ `depth` é€’å‡1ã€‚
ä½¿ç”¨ `Array.prototype.reduce()` å’Œ `Array.prototype.concat()` æ¥åˆå¹¶æ•°ç»„æˆ–è€…å…ƒç´ ã€‚
åŸºæœ¬æƒ…å†µä¸‹ï¼Œå½“`depth` ç­‰äº1æ—¶åœæ­¢é€’å½’ã€‚
å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°çš„æƒ…å†µä¸‹ï¼Œ `depth` é»˜è®¤ä¸º1ï¼ˆå•å±‚å±•å¼€ï¼‰ã€‚

```js
const flatten = (arr, depth = 1) =>
  arr.reduce((a, v) => a.concat(depth > 1 && Array.isArray(v) ? flatten(v, depth - 1) : v), []);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
flatten([1, [2], 3, 4]); // [1, 2, 3, 4]
flatten([1, [2, [3, [4, 5], 6], 7], 8], 2); // [1, 2, 3, [4, 5], 6, 7, 8]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### forEachRight

å¯¹æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ‰§è¡Œä¸€æ¬¡æ‰€æä¾›çš„å‡½æ•°ï¼Œä»æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ å¼€å§‹ã€‚


ä½¿ç”¨ `Array.prototype.slice(0)` å…‹éš†ç»™å®šçš„æ•°ç»„ï¼Œå¹¶ä½¿ç”¨`Array.prototype.reverse()` å°†å®ƒåè½¬ï¼Œç„¶åä½¿ç”¨`Array.prototype.forEach()`éå†åè½¬åçš„æ•°ç»„ã€‚


```js
const forEachRight = (arr, callback) =>
  arr
    .slice(0)
    .reverse()
    .forEach(callback);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
forEachRight([1, 2, 3, 4], val => console.log(val)); // '4', '3', '2', '1'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### groupBy

åŸºäºç»™å®šçš„å‡½æ•°å°†æ•°ç»„åˆ†ç»„ã€‚

ä½¿ç”¨ `Array.prototype.map()` å°†ç»„æ•°ä¸­çš„å€¼æ˜ å°„åˆ°ä¸€ä¸ªå‡½æ•°æˆ–è€…å±æ€§åã€‚

ä½¿ç”¨ `Array.prototype.reduce()` åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­çš„é”®ç”±æ˜ å°„çš„ç»“æœç”Ÿæˆã€‚

```js
const groupBy = (arr, fn) =>
  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val, i) => {
    acc[val] = (acc[val] || []).concat(arr[i]);
    return acc;
  }, {});
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
groupBy([6.1, 4.2, 6.3], Math.floor); // {4: [4.2], 6: [6.1, 6.3]}
groupBy(['one', 'two', 'three'], 'length'); // {3: ['one', 'two'], 5: ['three']}
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### head

è¿”å›åˆ—è¡¨çš„å¤´éƒ¨

ä½¿ç”¨ `arr[0]` è¿”å›ä¼ é€’æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

```js
const head = arr => arr[0];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
head([1, 2, 3]); // 1
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### indexOfAll

è¿”å›ä¸€ä¸ªæ•°ç»„ä¸­æ‰€æœ‰ `val` çš„ç´¢å¼•ã€‚
å¦‚æœ `val` ä¸å­˜åœ¨ï¼Œè¿”å› `[]` ã€‚

ä½¿ç”¨ `Array.prototype.reduce()` éå†å…ƒç´ ï¼Œå°†åŒ¹é…çš„å…ƒç´ ç´¢å¼•å­˜å‚¨ä¸‹æ¥ï¼Œè¿”å›ç´¢å¼•æ•°ç»„ã€‚

```js
const indexOfAll = (arr, val) => arr.reduce((acc, el, i) => (el === val ? [...acc, i] : acc), []);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
indexOfAll([1, 2, 3, 1, 2, 3], 1); // [0,3]
indexOfAll([1, 2, 3], 4); // []
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### initial

è¿”å›æ•°ç»„ä¸­é™¤æœ€åä¸€ä¸ªå…ƒç´ å¤–çš„æ‰€æœ‰å…ƒç´ ã€‚

ä½¿ç”¨ `arr.slice(0,-1)` è¿”å›æ•°ç»„ä¸­é™¤æœ€åä¸€ä¸ªå…ƒç´ å¤–çš„æ‰€æœ‰å…ƒç´ ã€‚

```js
const initial = arr => arr.slice(0, -1);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
initial([1, 2, 3]); // [1,2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### initialize2DArray

æ ¹æ®ç»™å®šçš„å®½ã€é«˜å’Œå€¼åˆå§‹åŒ–ä¸€ä¸ªäºŒç»´æ•°ç»„ã€‚

ä½¿ç”¨ `Array.prototype.map()` ç”Ÿæˆ`h`è¡Œï¼Œå…¶ä¸­æ¯ä¸€è¡Œéƒ½æ˜¯å¤§å°ä¸º`w`çš„æ–°æ•°ç»„ï¼Œå¹¶ç”¨å€¼åˆå§‹åŒ–ã€‚å¦‚æœæ²¡æœ‰æä¾›è¯¥å€¼ï¼Œåˆ™é»˜è®¤ä¸º`null`ã€‚

```js
const initialize2DArray = (w, h, val = null) =>
  Array.from({ length: h }).map(() => Array.from({ length: w }).fill(val));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
initialize2DArray(2, 2, 0); // [[0,0], [0,0]]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### initializeArrayWithRange

åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„ï¼Œè¯¥æ•°ç»„åŒ…æ‹¬ä» `start` åˆ° `end` æŒ‡å®šèŒƒå›´çš„æ•°å­—ï¼Œå¹¶ä¸”åŒ…æ‹¬å…±åŒçš„å…¬å·® `step` ã€‚

ä½¿ç”¨ `Array.from()` åˆ›å»ºä¸€ä¸ªæ‰€éœ€é•¿åº¦ `(end - start + 1)/step` çš„æ•°ç»„ï¼Œç„¶åæŒ‡å®šä¸€ä¸ªåŒ¹é…å‡½æ•°å°†æŒ‡å®šèŒƒå›´å†…çš„æ‰€éœ€å€¼å¡«å……åˆ°æ•°ç»„ä¸­ã€‚

ä½ å¯ä»¥çœç•¥ `start` ä½¿ç”¨é»˜è®¤å€¼`0`;
ä½ å¯ä»¥çœç•¥ `step` ä½¿ç”¨é»˜è®¤å€¼`1`;
```js
const initializeArrayWithRange = (end, start = 0, step = 1) =>
  Array.from({ length: Math.ceil((end - start + 1) / step) }, (v, i) => i * step + start);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
initializeArrayWithRange(5); // [0,1,2,3,4,5]
initializeArrayWithRange(7, 3); // [3,4,5,6,7]
initializeArrayWithRange(9, 0, 2); // [0,2,4,6,8]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### initializeArrayWithRangeRight

åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„ï¼Œè¯¥æ•°ç»„åŒ…æ‹¬ä» `start` åˆ° `end` æŒ‡å®šèŒƒå›´çš„æ•°å­—ï¼ˆåå‘çš„ï¼‰ï¼Œå¹¶ä¸”åŒ…æ‹¬å…±åŒçš„å…¬å·® `step` ã€‚

ä½¿ç”¨ `Array.from(Math.ceil((end+1-start)/step))` åˆ›å»ºä¸€ä¸ªæœŸæœ›é•¿åº¦çš„æ•°ç»„ï¼ˆä¸ºäº†å…¼å®¹ç»“æŸï¼Œå…ƒç´ çš„æ•°é‡ç­‰åŒäº`(end-start)/step` æˆ– `(end+1-start)/step`ï¼‰ï¼Œä½¿ç”¨`Array.prototype.map()`æ¥å¡«å……æœŸæœ›èŒƒå›´å†…çš„å€¼ã€‚

ä½ å¯ä»¥çœç•¥ `start` ä½¿ç”¨é»˜è®¤å€¼`0`ã€‚
ä½ å¯ä»¥çœç•¥ `step` ä½¿ç”¨é»˜è®¤å€¼`1`ã€‚
```js
const initializeArrayWithRangeRight = (end, start = 0, step = 1) =>
  Array.from({ length: Math.ceil((end + 1 - start) / step) }).map(
    (v, i, arr) => (arr.length - i - 1) * step + start
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
initializeArrayWithRangeRight(5); // [5,4,3,2,1,0]
initializeArrayWithRangeRight(7, 3); // [7,6,5,4,3]
initializeArrayWithRangeRight(9, 0, 2); // [8,6,4,2,0]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### initializeArrayWithValues

åˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„ï¼Œå¹¶ä¸”ä½¿ç”¨æŒ‡å®šçš„å€¼å¡«å……å®ƒã€‚

ä½¿ç”¨ `Array(n)` åˆ›å»ºä¸€ä¸ªæœŸæœ›é•¿åº¦çš„æ•°ç»„ï¼Œä½¿ç”¨ `fill(v)` ç”¨æœŸæœ›çš„å€¼å¡«å……æ•°ç»„ã€‚

ä½ å¯ä»¥çœç•¥å‚æ•° `val` ä½¿ç”¨é»˜è®¤å€¼`0`ã€‚


```js
const initializeArrayWithValues = (n, val = 0) => Array(n).fill(val);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
initializeArrayWithValues(5, 2); // [2, 2, 2, 2, 2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### initializeNDArray

ä½¿ç”¨ç»™å®šçš„å€¼åˆ›å»ºä¸€ä¸ªnç»´æ•°ç»„ã€‚

ä½¿ç”¨é€’å½’ã€‚ä½¿ç”¨ `Array.prototype.map()` æ¥ç”Ÿæˆè¡Œï¼Œè¿™äº›è¡Œæ¯ä¸€ä¸ªéƒ½æ˜¯ä½¿ç”¨`initializeNDArray`åˆå§‹åŒ–çš„æ–°æ•°ç»„ã€‚

```js
const initializeNDArray = (val, ...args) =>
  args.length === 0
    ? val
    : Array.from({ length: args[0] }).map(() => initializeNDArray(val, ...args.slice(1)));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
initializeNDArray(1, 3); // [1,1,1]
initializeNDArray(5, 2, 2, 2); // [[[5,5],[5,5]],[[5,5],[5,5]]]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### intersection

è¿”å›ä¸¤ä¸ªæ•°ç»„ä¸­éƒ½å­˜åœ¨çš„å…ƒç´ åˆ—è¡¨ã€‚

ä» `b`åˆ›å»ºä¸€ä¸ª `Set` ï¼Œç„¶ååœ¨`a`ä¸Šä½¿ç”¨`Array.prototype.filter()`æ¥åªä¿ç•™ `b`ä¸­åŒ…å«çš„å…ƒç´ ã€‚

```js
const intersection = (a, b) => {
  const s = new Set(b);
  return a.filter(x => s.has(x));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
intersection([1, 2, 3], [4, 3, 2]); // [2, 3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### intersectionBy

å°†æä¾›çš„å‡½æ•°åº”åº”ç”¨åˆ°ä¸¤ä¸ªæ•°ç»„çš„æ¯ä¸ªå…ƒç´ ä¸Šï¼Œç„¶åè¿”å›ä¸¤ä¸ªæ•°ç»„ä¸­éƒ½å­˜åœ¨çš„å…ƒç´ åˆ—è¡¨

é€šè¿‡å°† `fn` åº”ç”¨åˆ° `b`çš„æ‰€æœ‰å…ƒç´ æ¥åˆ›å»ºä¸€ä¸ª `Set`ï¼Œç„¶ååœ¨ `a` ä¸Šè°ƒç”¨ `Array.prototype.filter()` æ¥åªä¿ç•™è°ƒç”¨ `fn` å `b` ä¸­åŒ…å«çš„å…ƒç´ ã€‚

```js
const intersectionBy = (a, b, fn) => {
  const s = new Set(b.map(fn));
  return a.filter(x => s.has(fn(x)));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [2.1]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### intersectionWith

è¿”å›ä¸¤ä¸ªæ•°ç»„ä¸­éƒ½å­˜åœ¨çš„å…ƒç´ åˆ—è¡¨ï¼Œä½¿ç”¨ç»™å®šçš„æ¯”è¾ƒå‡½æ•°ã€‚

ç»“åˆä½¿ç”¨`Array.prototype.filter()`å’Œ `Array.prototype.findIndex()` æ¥ç¡®å®šäº¤å‰å€¼ã€‚

```js
const intersectionWith = (a, b, comp) => a.filter(x => b.findIndex(y => comp(x, y)) !== -1);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
intersectionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) => Math.round(a) === Math.round(b)); // [1.5, 3, 0]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isSorted

å¦‚æœæ•°ç»„æ˜¯å‡åºæ’åºçš„ï¼Œè¿”å› `1` ï¼Œå¦‚æœæ•°ç»„æ˜¯é™åºæ’åºçš„è¿”å› `-1`ï¼Œå¦‚æœæ•°ç»„æ²¡æœ‰æ’åºè¿”å›`0` ã€‚

è®¡ç®—å‰ä¸¤ä¸ªå…ƒç´ çš„é¡ºåº `direction`ã€‚ä½¿ç”¨ `Object.entries()` æ¥éå†æ•°ç»„ï¼Œç—…æˆå¯¹æ¯”è¾ƒã€‚å¦‚æœ `direction` æ”¹å˜ï¼Œè¿”å› `0` ï¼Œå¦‚æœåˆ°è¾¾æœ€åä¸€ä¸ªå…ƒç´ ï¼Œè¿”å› `direction` ã€‚

```js
const isSorted = arr => {
  let direction = -(arr[0] - arr[1]);
  for (let [i, val] of arr.entries()) {
    direction = !direction ? -(arr[i - 1] - arr[i]) : direction;
    if (i === arr.length - 1) return !direction ? 0 : direction;
    else if ((val - arr[i + 1]) * direction > 0) return 0;
  }
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isSorted([0, 1, 2, 2]); // 1
isSorted([4, 3, 2]); // -1
isSorted([4, 3, 5]); // 0
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### join

å°†æ•°ç»„ä¸­æ‰€æœ‰çš„å…ƒç´ è¿æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›è¿™ä¸ªå­—ç¬¦ä¸²ã€‚ä½¿ç”¨ä¸€ä¸ªåˆ†éš”ç¬¦å’Œç»“æŸåˆ†éš”ç¬¦ã€‚

ä½¿ç”¨ `Array.prototype.reduce()` å°†å…ƒç´ åˆå¹¶æˆå­—ç¬¦ä¸²ã€‚
å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°ï¼Œ`separator`ï¼Œé»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨ä¸€ä¸ªé»˜è®¤åˆ†éš”ç¬¦`','`ã€‚
å¿½ç•¥ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œ `end`ï¼Œä½¿ç”¨å’Œ`separator`ç›¸åŒçš„å€¼ä½œä¸ºé»˜è®¤å€¼ã€‚

```js
const join = (arr, separator = ',', end = separator) =>
  arr.reduce(
    (acc, val, i) =>
      i === arr.length - 2
        ? acc + val + end
        : i === arr.length - 1
          ? acc + val
          : acc + val + separator,
    ''
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
join(['pen', 'pineapple', 'apple', 'pen'], ',', '&'); // "pen,pineapple,apple&pen"
join(['pen', 'pineapple', 'apple', 'pen'], ','); // "pen,pineapple,apple,pen"
join(['pen', 'pineapple', 'apple', 'pen']); // "pen,pineapple,apple,pen"
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### JSONtoCSV 

å°†å¯¹è±¡æ•°ç»„è½¬æ¢ä¸ºä»…åŒ…å«æŒ‡å®šçš„`columns`çš„é€—å·åˆ†éš”å€¼`(CSV)`å­—ç¬¦ä¸²ã€‚

ä½¿ç”¨ `Array.prototype.join(delimiter)` åˆå¹¶`columns`ä¸­çš„æ‰€æœ‰åç§°ä»¥åˆ›å»ºç¬¬ä¸€è¡Œã€‚ã€

ä½¿ç”¨ `Array.prototype.map()` å’Œ `Array.prototype.reduce()` ä¸ºæ¯ä¸ªå¯¹è±¡åˆ›å»ºä¸€è¡Œï¼Œç”¨ç©ºå­—ç¬¦ä¸²æ›¿æ¢ä¸å­˜åœ¨çš„å€¼ï¼Œåªæ˜ å°„â€œåˆ—â€ä¸­çš„å€¼ã€‚

ä½¿ç”¨` Array.prototype.join('\n') `å°†æ‰€æœ‰è¡Œç»„åˆæˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚
å¿½ç•¥ç¬¬ä¸‰ä¸ªå‚æ•° `delimiter`,ä½¿ç”¨é»˜è®¤åˆ†éš”ç¬¦ `,`ã€‚

```js
const JSONtoCSV = (arr, columns, delimiter = ',') =>
  [
    columns.join(delimiter),
    ...arr.map(obj =>
      columns.reduce(
        (acc, key) => `${acc}${!acc.length ? '' : delimiter}"${!obj[key] ? '' : obj[key]}"`,
        ''
      )
    )
  ].join('\n');
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
JSONtoCSV([{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }], ['a', 'b']); // 'a,b\n"1","2"\n"3","4"\n"6",""\n"","7"'
JSONtoCSV([{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }], ['a', 'b'], ';'); // 'a;b\n"1";"2"\n"3";"4"\n"6";""\n"";"7"'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### last

è¿”å›æ•°ç»„ä¸­æœ€åä¸€ä¸ªå…ƒç´ ã€‚

ä½¿ç”¨ `arr.length - 1` æ¥è®¡ç®—ç»™å®šæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•ï¼Œç„¶åè¿”å›å®ƒã€‚

```js
const last = arr => arr[arr.length - 1];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
last([1, 2, 3]); // 3
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### longestItem


è·å–ä»»æ„æ•°é‡çš„å¯è¿­ä»£å¯¹è±¡æˆ–å…·æœ‰ `length` å±æ€§çš„å¯¹è±¡ï¼Œå¹¶è¿”å›å…¶ä¸­æœ€é•¿çš„ä¸€ä¸ªã€‚

å¦‚æœå¤šä¸ªå¯¹è±¡å…·æœ‰ç›¸åŒçš„é•¿åº¦ï¼Œåˆ™è¿”å›ç¬¬ä¸€ä¸ªå¯¹è±¡ã€‚
å¦‚æœæ²¡æœ‰æä¾›å‚æ•°ï¼Œåˆ™è¿”å›â€œundefinedâ€ã€‚

ä½¿ç”¨` Array.prototype.reduce() `ï¼Œæ¯”è¾ƒå¯¹è±¡çš„` length `ä»¥æ‰¾åˆ°æœ€é•¿çš„å¯¹è±¡ã€‚


```js
const longestItem = (...vals) => vals.reduce((a, x) => (x.length > a.length ? x : a));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
longestItem('this', 'is', 'a', 'testcase'); // 'testcase'
longestItem(...['a', 'ab', 'abc']); // 'abc'
longestItem(...['a', 'ab', 'abc'], 'abcd'); // 'abcd'
longestItem([1, 2, 3], [1, 2], [1, 2, 3, 4, 5]); // [1, 2, 3, 4, 5]
longestItem([1, 2, 3], 'foobar'); // 'foobar'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### mapObject 

ä½¿ç”¨å‡½æ•°å°†æ•°ç»„çš„å€¼æ˜ å°„åˆ°å¯¹è±¡ï¼Œå…¶ä¸­é”®å€¼å¯¹ç”±ä½œä¸ºé”®çš„åŸå§‹å€¼å’Œæ˜ å°„çš„å€¼ç»„æˆã€‚

ä½¿ç”¨åŒ¿åå†…éƒ¨å‡½æ•°ä½œç”¨åŸŸå£°æ˜æœªå®šä¹‰çš„å†…å­˜ç©ºé—´ï¼Œä½¿ç”¨é—­åŒ…å­˜å‚¨è¿”å›å€¼ã€‚ä½¿ç”¨ä¸€ä¸ªæ–°çš„ `Array` æ¥å­˜å‚¨æ•°ç»„ï¼Œå…¶ä¸­åŒ…å«å‡½æ•°åœ¨å…¶æ•°æ®é›†ä¸Šçš„æ˜ å°„ï¼Œå¹¶ä½¿ç”¨é€—å·æ“ä½œç¬¦è¿”å›ç¬¬äºŒä¸ªæ­¥éª¤ï¼Œè€Œä¸éœ€è¦ä»ä¸€ä¸ªä¸Šä¸‹æ–‡ç§»åŠ¨åˆ°å¦ä¸€ä¸ªä¸Šä¸‹æ–‡(ç”±äºé—­åŒ…å’Œæ“ä½œé¡ºåº)ã€‚

```js
const mapObject = (arr, fn) =>
  (a => (
    (a = [arr, arr.map(fn)]), a[0].reduce((acc, val, ind) => ((acc[val] = a[1][ind]), acc), {})
  ))();
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const squareIt = arr => mapObject(arr, a => a * a);
squareIt([1, 2, 3]); // { 1: 1, 2: 4, 3: 9 }
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### maxN

è¿”å›ç»™å®šæ•°ç»„ä¸­å‰ `n` å¤§çš„å…ƒç´ ã€‚
å¦‚æœ `n` æ¯”ç»™å®šçš„æ•°ç»„é•¿åº¦è¿˜è¦å¤§ï¼Œè¿”å›åŸå§‹æ•°ç»„ï¼ˆæŒ‰é™åºæ’åˆ—ï¼‰ã€‚

ä½¿ç”¨ `Array.prototype.sort()` ç»“åˆå±•å¼€æ“ä½œç¬¦ (`...`) åˆ›å»ºä¸€ä¸ªæ•°ç»„çš„æµ…å…‹éš†ï¼Œå¹¶æŒ‰ç…§é™åºæ’åºã€‚
ä½¿ç”¨ `Array.prototype.slice()` è·å–æŒ‡å®šæ•°é‡çš„å…ƒç´ ã€‚
å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°, `n`, è¿”å›ä¸€ä¸ªå•å…ƒç´ æ•°ç»„ã€‚

```js
const maxN = (arr, n = 1) => [...arr].sort((a, b) => b - a).slice(0, n);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
maxN([1, 2, 3]); // [3]
maxN([1, 2, 3], 2); // [3,2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### minN

è¿”å›ç»™å®šæ•°ç»„ä¸­å‰ `n` å°çš„å…ƒç´ ã€‚
å¦‚æœ `n` æ¯”ç»™å®šçš„æ•°ç»„é•¿åº¦è¿˜è¦å¤§ï¼Œè¿”å›åŸå§‹æ•°ç»„ï¼ˆæŒ‰å‡åºæ’åˆ—ï¼‰ã€‚

ä½¿ç”¨ `Array.prototype.sort()` ç»“åˆå±•å¼€æ“ä½œç¬¦ (`...`) åˆ›å»ºä¸€ä¸ªæ•°ç»„çš„æµ…å…‹éš†ï¼Œå¹¶æŒ‰ç…§å‡åºæ’åºã€‚
ä½¿ç”¨ `Array.prototype.slice()` è·å–æŒ‡å®šæ•°é‡çš„å…ƒç´ ã€‚
å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°, `n`, è¿”å›ä¸€ä¸ªå•å…ƒç´ æ•°ç»„ã€‚

```js
const minN = (arr, n = 1) => [...arr].sort((a, b) => a - b).slice(0, n);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
minN([1, 2, 3]); // [1]
minN([1, 2, 3], 2); // [1,2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### none

å¦‚æœå¯¹é›†åˆä¸­æ‰€æœ‰çš„å…ƒç´ æ‰§è¡Œåˆ¤å®šå‡½æ•°å…¨éƒ¨éƒ½è¿”å›`false`ï¼Œé‚£ä¹ˆå‡½æ•°è¿”å›`true`ï¼Œå¦åˆ™è¿”å›`false`ã€‚

åŸºäº`fn`ä½¿ç”¨`Array.prototype.some()`æ¥æµ‹è¯•æ˜¯å¦é›†åˆä¸­æœ‰ä»»æ„ä¸€ä¸ªå…ƒç´ è¿”å›`true`ã€‚

å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°ï¼Œ`fn`ï¼Œä½¿ç”¨`Boolean`ä½œä¸ºé»˜è®¤å€¼ã€‚

```js
const none = (arr, fn = Boolean) => !arr.some(fn);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
none([0, 1, 3, 0], x => x == 2); // true
none([0, 0, 0]); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### nthElement

è¿”å›æ•°ç»„ä¸­ç¬¬`n`ä¸ªå…ƒç´ (`n`å¯ä»¥æ˜¯è´Ÿæ•°)ã€‚

ä½¿ç”¨`Array.prototype.slice()`è·å¾—åœ¨é¦–ä½åŒ…å«ç¬¬`n`ä¸ªå…ƒç´ çš„æ•°ç»„ã€‚

å¦‚æœä¸‹æ ‡è¶Šç•Œï¼Œè¿”å›`undefined`ã€‚

å¦‚æœæ²¡æœ‰ç¬¬äºŒä¸ªå‚æ•°ï¼Œ`n`ï¼Œè¿”å›æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

```js
const nthElement = (arr, n = 0) => (n === -1 ? arr.slice(n) : arr.slice(n, n + 1))[0];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
nthElement(['a', 'b', 'c'], 1); // 'b'
nthElement(['a', 'b', 'b'], -3); // 'a'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### offset

å°†æŒ‡å®šæ•°é‡çš„å…ƒç´ ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ã€‚

ä½¿ç”¨ `Array.prototype.slice()` ä¸¤æ¬¡æ¥è·å–æŒ‡å®šç´¢å¼•åé¢çš„å…ƒç´ å’Œå‰é¢çš„å…ƒç´ ã€‚

ä½¿ç”¨æ‰©å±•æ“ä½œç¬¦(`...`)å°†ä¸¤ä¸ªæ•°ç»„åˆå¹¶æˆä¸€ä¸ªæ•°ç»„ã€‚

å¦‚æœ`offset`æ˜¯è´Ÿï¼Œå…ƒç´ å°†è¢«ä»æœ«å°¾ç§»åŠ¨åˆ°å¼€å§‹ã€‚
```js
const offset = (arr, offset) => [...arr.slice(offset), ...arr.slice(0, offset)];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
offset([1, 2, 3, 4, 5], 2); // [3, 4, 5, 1, 2]
offset([1, 2, 3, 4, 5], -2); // [4, 5, 1, 2, 3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### partition

æ ¹æ®æä¾›çš„å‡½æ•°å¯¹æ¯ä¸ªå…ƒç´ çš„çœŸå®æ€§ï¼Œå°†å…ƒç´ åˆ†ç»„ä¸ºä¸¤ä¸ªæ•°ç»„ã€‚

ä½¿ç”¨`Array.prototype.reduce()`åˆ›å»ºä¸€ä¸ªç”±ä¸¤ä¸ªæ•°ç»„ç»„æˆçš„æ•°ç»„ã€‚

ä½¿ç”¨`Array.prototype.push()`å°†æ‰§è¡Œ`fn`è¿”å›`true`çš„å…ƒç´ æ·»åŠ åˆ°ç¬¬ä¸€ä¸ªæ•°ç»„ï¼Œæ‰§è¡Œ`fn`è¿”å›`false`çš„å…ƒç´ æ·»åŠ åˆ°ç¬¬äºŒä¸ªæ•°ç»„ã€‚

```js
const partition = (arr, fn) =>
  arr.reduce(
    (acc, val, i, arr) => {
      acc[fn(val, i, arr) ? 0 : 1].push(val);
      return acc;
    },
    [[], []]
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const users = [{ user: 'barney', age: 36, active: false }, { user: 'fred', age: 40, active: true }];
partition(users, o => o.active); // [[{ 'user': 'fred',    'age': 40, 'active': true }],[{ 'user': 'barney',  'age': 36, 'active': false }]]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### permutations ![advanced](/advanced.svg)

ç”Ÿæˆæ•°ç»„å…ƒç´ çš„æ‰€æœ‰æ’åˆ—(åŒ…æ‹¬é‡å¤å…ƒç´ )

ä½¿ç”¨é€’å½’ã€‚

å¯¹äºç»™å®šæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œä¸ºå…¶å…¶ä½™å…ƒç´ åˆ›å»ºæ‰€æœ‰éƒ¨åˆ†æ’åˆ—ã€‚

ä½¿ç”¨`Array.prototype.map()`ç»„åˆæ¯ä¸ªå…ƒç´ çš„éƒ¨åˆ†æ’åˆ—ï¼Œç„¶åä½¿ç”¨`Array.prototype.reduce()`ç»„åˆä¸€ä¸ªæ•°ç»„ä¸­çš„æ‰€æœ‰æ’åˆ—ã€‚

åŸºæœ¬æƒ…å†µæ˜¯æ•°ç»„`length` ç­‰äº `2` æˆ– `1`ã€‚

```js
const permutations = arr => {
  if (arr.length <= 2) return arr.length === 2 ? [arr, [arr[1], arr[0]]] : arr;
  return arr.reduce(
    (acc, item, i) =>
      acc.concat(
        permutations([...arr.slice(0, i), ...arr.slice(i + 1)]).map(val => [item, ...val])
      ),
    []
  );
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
permutations([1, 33, 5]); // [ [ 1, 33, 5 ], [ 1, 5, 33 ], [ 33, 1, 5 ], [ 33, 5, 1 ], [ 5, 1, 33 ], [ 5, 33, 1 ] ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### pull

ä¿®æ”¹åŸå§‹æ•°ç»„ä»¥è¿‡æ»¤æ‰æŒ‡å®šçš„å€¼ã€‚

ä½¿ç”¨`Array.prototype.filter()` å’Œ `Array.prototype.includes()`å°†ä¸éœ€è¦è¿‡æ»¤çš„å€¼æå–å‡ºæ¥ã€‚

ä½¿ç”¨`Array.prototypeã€‚length = 0 `é€šè¿‡å°†æ•°ç»„çš„é•¿åº¦é‡ç½®ä¸º`0`æ¥æ”¹å˜æ•°ç»„ä¸­ä¼ é€’çš„å€¼ï¼Œå¹¶ä½¿ç”¨` array .prototype.push() `ä»…ç”¨æå–çš„å€¼é‡æ–°å¡«å……æ•°ç»„ã€‚

```js
const pull = (arr, ...args) => {
  let argState = Array.isArray(args[0]) ? args[0] : args;
  let pulled = arr.filter((v, i) => !argState.includes(v));
  arr.length = 0;
  pulled.forEach(v => arr.push(v));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
let myArray = ['a', 'b', 'c', 'a', 'b', 'c'];
pull(myArray, 'a', 'c'); // myArray = [ 'b', 'b' ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### pullAtIndex ![advanced](/advanced.svg)

ä¿®æ”¹åŸå§‹æ•°ç»„ï¼Œä»¥è¿‡æ»¤æŒ‡å®šç´¢å¼•å¤„çš„å€¼ã€‚

ä½¿ç”¨`Array.prototype.filter()` å’Œ `Array.prototype.includes()`å°†ä¸éœ€è¦è¿‡æ»¤çš„å€¼æå–å‡ºæ¥ã€‚

ä½¿ç”¨`Array.prototypeã€‚length = 0 `é€šè¿‡å°†æ•°ç»„çš„é•¿åº¦é‡ç½®ä¸º`0`æ¥æ”¹å˜æ•°ç»„ä¸­ä¼ é€’çš„å€¼ï¼Œå¹¶ä½¿ç”¨` array .prototype.push() `ä»…ç”¨æå–çš„å€¼é‡æ–°å¡«å……æ•°ç»„ã€‚

```js
const pullAtIndex = (arr, pullArr) => {
  let removed = [];
  let pulled = arr
    .map((v, i) => (pullArr.includes(i) ? removed.push(v) : v))
    .filter((v, i) => !pullArr.includes(i));
  arr.length = 0;
  pulled.forEach(v => arr.push(v));
  return removed;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
let myArray = ['a', 'b', 'c', 'd'];
let pulled = pullAtIndex(myArray, [1, 3]); // myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### pullAtValue ![advanced](/advanced.svg)

Mutates the original array to filter out the values specified. Returns the removed elements.

Use `Array.prototype.filter()` and `Array.prototype.includes()` to pull out the values that are not needed.
Use `Array.prototype.length = 0` to mutate the passed in an array by resetting it's length to zero and `Array.prototype.push()` to re-populate it with only the pulled values.
Use `Array.prototype.push()` to keep track of pulled values

```js
const pullAtValue = (arr, pullArr) => {
  let removed = [],
    pushToRemove = arr.forEach((v, i) => (pullArr.includes(v) ? removed.push(v) : v)),
    mutateTo = arr.filter((v, i) => !pullArr.includes(v));
  arr.length = 0;
  mutateTo.forEach(v => arr.push(v));
  return removed;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
let myArray = ['a', 'b', 'c', 'd'];
let pulled = pullAtValue(myArray, ['b', 'd']); // myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### pullBy ![advanced](/advanced.svg)

Mutates the original array to filter out the values specified, based on a given iterator function.

Check if the last argument provided in a function.
Use `Array.prototype.map()` to apply the iterator function `fn` to all array elements.
Use `Array.prototype.filter()` and `Array.prototype.includes()` to pull out the values that are not needed.
Use `Array.prototype.length = 0` to mutate the passed in an array by resetting it's length to zero and `Array.prototype.push()` to re-populate it with only the pulled values.

```js
const pullBy = (arr, ...args) => {
  const length = args.length;
  let fn = length > 1 ? args[length - 1] : undefined;
  fn = typeof fn == 'function' ? (args.pop(), fn) : undefined;
  let argState = (Array.isArray(args[0]) ? args[0] : args).map(val => fn(val));
  let pulled = arr.filter((v, i) => !argState.includes(fn(v)));
  arr.length = 0;
  pulled.forEach(v => arr.push(v));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
var myArray = [{ x: 1 }, { x: 2 }, { x: 3 }, { x: 1 }];
pullBy(myArray, [{ x: 1 }, { x: 3 }], o => o.x); // myArray = [{ x: 2 }]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### reducedFilter

Filter an array of objects based on a condition while also filtering out unspecified keys.

Use `Array.prototype.filter()` to filter the array based on the predicate `fn` so that it returns the objects for which the condition returned a truthy value.
On the filtered array, use `Array.prototype.map()` to return the new object using `Array.prototype.reduce()` to filter out the keys which were not supplied as the `keys` argument.

```js
const reducedFilter = (data, keys, fn) =>
  data.filter(fn).map(el =>
    keys.reduce((acc, key) => {
      acc[key] = el[key];
      return acc;
    }, {})
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const data = [
  {
    id: 1,
    name: 'john',
    age: 24
  },
  {
    id: 2,
    name: 'mike',
    age: 50
  }
];

reducedFilter(data, ['id', 'name'], item => item.age > 24); // [{ id: 2, name: 'mike'}]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### reduceSuccessive

Applies a function against an accumulator and each element in the array (from left to right), returning an array of successively reduced values.

Use `Array.prototype.reduce()` to apply the given function to the given array, storing each new result.

```js
const reduceSuccessive = (arr, fn, acc) =>
  arr.reduce((res, val, i, arr) => (res.push(fn(res.slice(-1)[0], val, i, arr)), res), [acc]);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
reduceSuccessive([1, 2, 3, 4, 5, 6], (acc, val) => acc + val, 0); // [0, 1, 3, 6, 10, 15, 21]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### reduceWhich

Returns the minimum/maximum value of an array, after applying the provided function to set comparing rule.

Use `Array.prototype.reduce()` in combination with the `comparator` function to get the appropriate element in the array.
You can omit the second parameter, `comparator`, to use the default one that returns the minimum element in the array.

```js
const reduceWhich = (arr, comparator = (a, b) => a - b) =>
  arr.reduce((a, b) => (comparator(a, b) >= 0 ? b : a));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
reduceWhich([1, 3, 2]); // 1
reduceWhich([1, 3, 2], (a, b) => b - a); // 3
reduceWhich(
  [{ name: 'Tom', age: 12 }, { name: 'Jack', age: 18 }, { name: 'Lucy', age: 9 }],
  (a, b) => a.age - b.age
); // {name: "Lucy", age: 9}
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### reject

Takes a predicate and array, like `Array.prototype.filter()`, but only keeps `x` if `pred(x) === false`.

```js
const reject = (pred, array) => array.filter((...args) => !pred(...args));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
reject(x => x % 2 === 0, [1, 2, 3, 4, 5]); // [1, 3, 5]
reject(word => word.length > 4, ['Apple', 'Pear', 'Kiwi', 'Banana']); // ['Pear', 'Kiwi']
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### remove

Removes elements from an array for which the given function returns `false`.

Use `Array.prototype.filter()` to find array elements that return truthy values and `Array.prototype.reduce()` to remove elements using `Array.prototype.splice()`.
The `func` is invoked with three arguments (`value, index, array`).

```js

const remove = (arr, func) =>
  Array.isArray(arr)
    ? arr.filter(func).reduce((acc, val) => {
      arr.splice(arr.indexOf(val), 1);
      return acc.concat(val);
    }, [])
    : [];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
remove([1, 2, 3, 4], n => n % 2 === 0); // [2, 4]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sample

Returns a random element from an array.

Use `Math.random()` to generate a random number, multiply it by `length` and round it off to the nearest whole number using `Math.floor()`.
This method also works with strings.

```js
const sample = arr => arr[Math.floor(Math.random() * arr.length)];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sample([3, 7, 9, 11]); // 9
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sampleSize

Gets `n` random elements at unique keys from `array` up to the size of `array`.

Shuffle the array using the [Fisher-Yates algorithm](https://github.com/30-seconds/30-seconds-of-code#shuffle).
Use `Array.prototype.slice()` to get the first `n` elements.
Omit the second argument, `n` to get only one element at random from the array.

```js
const sampleSize = ([...arr], n = 1) => {
  let m = arr.length;
  while (m) {
    const i = Math.floor(Math.random() * m--);
    [arr[m], arr[i]] = [arr[i], arr[m]];
  }
  return arr.slice(0, n);
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sampleSize([1, 2, 3], 2); // [3,1]
sampleSize([1, 2, 3], 4); // [2,3,1]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### shank

Has the same functionality as [`Array.prototype.splice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice), but returning a new array instead of mutating the original array.

Use `Array.prototype.slice()` and `Array.prototype.concat()` to get a new array with the new contents after removing existing elements and/or adding new elements.
Omit the second argument, `index`, to start at `0`.
Omit the third argument, `delCount`, to remove `0` elements.
Omit the fourth argument, `elements`, in order to not add any new elements.

```js
const shank = (arr, index = 0, delCount = 0, ...elements) =>
  arr
    .slice(0, index)
    .concat(elements)
    .concat(arr.slice(index + delCount));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const names = ['alpha', 'bravo', 'charlie'];
const namesAndDelta = shank(names, 1, 0, 'delta'); // [ 'alpha', 'delta', 'bravo', 'charlie' ]
const namesNoBravo = shank(names, 1, 1); // [ 'alpha', 'charlie' ]
console.log(names); // ['alpha', 'bravo', 'charlie']
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### shuffle

Randomizes the order of the values of an array, returning a new array.

Uses the [Fisher-Yates algorithm](https://github.com/30-seconds/30-seconds-of-code#shuffle) to reorder the elements of the array.

```js
const shuffle = ([...arr]) => {
  let m = arr.length;
  while (m) {
    const i = Math.floor(Math.random() * m--);
    [arr[m], arr[i]] = [arr[i], arr[m]];
  }
  return arr;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const foo = [1, 2, 3];
shuffle(foo); // [2, 3, 1], foo = [1, 2, 3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### similarity

Returns an array of elements that appear in both arrays.

Use `Array.prototype.filter()` to remove values that are not part of `values`, determined using `Array.prototype.includes()`.

```js
const similarity = (arr, values) => arr.filter(v => values.includes(v));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
similarity([1, 2, 3], [1, 2, 4]); // [1, 2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sortedIndex

Returns the lowest index at which value should be inserted into array in order to maintain its sort order.

Check if the array is sorted in descending order (loosely).
Use `Array.prototype.findIndex()` to find the appropriate index where the element should be inserted.

```js
const sortedIndex = (arr, n) => {
  const isDescending = arr[0] > arr[arr.length - 1];
  const index = arr.findIndex(el => (isDescending ? n >= el : n <= el));
  return index === -1 ? arr.length : index;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sortedIndex([5, 3, 2, 1], 4); // 1
sortedIndex([30, 50], 40); // 1
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sortedIndexBy

Returns the lowest index at which value should be inserted into array in order to maintain its sort order, based on a provided iterator function.

Check if the array is sorted in descending order (loosely).
Use `Array.prototype.findIndex()` to find the appropriate index where the element should be inserted, based on the iterator function `fn`.

```js
const sortedIndexBy = (arr, n, fn) => {
  const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]);
  const val = fn(n);
  const index = arr.findIndex(el => (isDescending ? val >= fn(el) : val <= fn(el)));
  return index === -1 ? arr.length : index;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sortedIndexBy([{ x: 4 }, { x: 5 }], { x: 4 }, o => o.x); // 0
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sortedLastIndex

Returns the highest index at which value should be inserted into array in order to maintain its sort order.

Check if the array is sorted in descending order (loosely).
Use `Array.prototype.reverse()` and `Array.prototype.findIndex()` to find the appropriate last index where the element should be inserted.

```js
const sortedLastIndex = (arr, n) => {
  const isDescending = arr[0] > arr[arr.length - 1];
  const index = arr.reverse().findIndex(el => (isDescending ? n <= el : n >= el));
  return index === -1 ? 0 : arr.length - index;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sortedLastIndex([10, 20, 30, 30, 40], 30); // 4
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sortedLastIndexBy

Returns the highest index at which value should be inserted into array in order to maintain its sort order, based on a provided iterator function.

Check if the array is sorted in descending order (loosely).
Use `Array.prototype.map()` to apply the iterator function to all elements of the array.
Use `Array.prototype.reverse()` and `Array.prototype.findIndex()` to find the appropriate last index where the element should be inserted, based on the provided iterator function.

```js
const sortedLastIndexBy = (arr, n, fn) => {
  const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]);
  const val = fn(n);
  const index = arr
    .map(fn)
    .reverse()
    .findIndex(el => (isDescending ? val <= el : val >= el));
  return index === -1 ? 0 : arr.length - index;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sortedLastIndexBy([{ x: 4 }, { x: 5 }], { x: 4 }, o => o.x); // 1
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### stableSort ![advanced](/advanced.svg)

Performs stable sorting of an array, preserving the initial indexes of items when their values are the same.
Does not mutate the original array, but returns a new array instead.

Use `Array.prototype.map()` to pair each element of the input array with its corresponding index.
Use `Array.prototype.sort()` and a `compare` function to sort the list, preserving their initial order if the items compared are equal.
Use `Array.prototype.map()` to convert back to the initial array items.

```js
const stableSort = (arr, compare) =>
  arr
    .map((item, index) => ({ item, index }))
    .sort((a, b) => compare(a.item, b.item) || a.index - b.index)
    .map(({ item }) => item);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const stable = stableSort(arr, () => 0); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### symmetricDifference

Returns the symmetric difference between two arrays, without filtering out duplicate values.

Create a `Set` from each array, then use `Array.prototype.filter()` on each of them to only keep values not contained in the other.

```js
const symmetricDifference = (a, b) => {
  const sA = new Set(a),
    sB = new Set(b);
  return [...a.filter(x => !sB.has(x)), ...b.filter(x => !sA.has(x))];
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
symmetricDifference([1, 2, 3], [1, 2, 4]); // [3, 4]
symmetricDifference([1, 2, 2], [1, 3, 1]); // [2, 2, 3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### symmetricDifferenceBy

Returns the symmetric difference between two arrays, after applying the provided function to each array element of both.

Create a `Set` by applying `fn` to each array's elements, then use `Array.prototype.filter()` on each of them to only keep values not contained in the other.

```js
const symmetricDifferenceBy = (a, b, fn) => {
  const sA = new Set(a.map(v => fn(v))),
    sB = new Set(b.map(v => fn(v)));
  return [...a.filter(x => !sB.has(fn(x))), ...b.filter(x => !sA.has(fn(x)))];
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
symmetricDifferenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [ 1.2, 3.4 ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### symmetricDifferenceWith

Returns the symmetric difference between two arrays, using a provided function as a comparator.

Use `Array.prototype.filter()` and `Array.prototype.findIndex()` to find the appropriate values.

```js
const symmetricDifferenceWith = (arr, val, comp) => [
  ...arr.filter(a => val.findIndex(b => comp(a, b)) === -1),
  ...val.filter(a => arr.findIndex(b => comp(a, b)) === -1)
];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
symmetricDifferenceWith(
  [1, 1.2, 1.5, 3, 0],
  [1.9, 3, 0, 3.9],
  (a, b) => Math.round(a) === Math.round(b)
); // [1, 1.2, 3.9]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### tail

Returns all elements in an array except for the first one.

Return `Array.prototype.slice(1)` if the array's `length` is more than `1`, otherwise, return the whole array.

```js
const tail = arr => (arr.length > 1 ? arr.slice(1) : arr);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
tail([1, 2, 3]); // [2,3]
tail([1]); // [1]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### take

Returns an array with n elements removed from the beginning.

Use `Array.prototype.slice()` to create a slice of the array with `n` elements taken from the beginning.

```js
const take = (arr, n = 1) => arr.slice(0, n);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
take([1, 2, 3], 5); // [1, 2, 3]
take([1, 2, 3], 0); // []
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### takeRight

Returns an array with n elements removed from the end.

Use `Array.prototype.slice()` to create a slice of the array with `n` elements taken from the end.

```js
const takeRight = (arr, n = 1) => arr.slice(arr.length - n, arr.length);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
takeRight([1, 2, 3], 2); // [ 2, 3 ]
takeRight([1, 2, 3]); // [3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### takeRightWhile

Removes elements from the end of an array until the passed function returns `true`. Returns the removed elements.

Loop through the array, using a `Array.prototype.reduceRight()` and accumulating elements while the function returns falsy value.

```js
const takeRightWhile = (arr, func) =>
  arr.reduceRight((acc, el) => (func(el) ? acc : [el, ...acc]), []);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
takeRightWhile([1, 2, 3, 4], n => n < 3); // [3, 4]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### takeWhile

Removes elements in an array until the passed function returns `true`. Returns the removed elements.

Loop through the array, using a `for...of` loop over `Array.prototype.entries()` until the returned value from the function is `true`.
Return the removed elements, using `Array.prototype.slice()`.

```js
const takeWhile = (arr, func) => {
  for (const [i, val] of arr.entries()) if (func(val)) return arr.slice(0, i);
  return arr;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
takeWhile([1, 2, 3, 4], n => n >= 3); // [1, 2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### toHash

Reduces a given Array-like into a value hash (keyed data store).

Given an Iterable or Array-like structure, call `Array.prototype.reduce.call()` on the provided object to step over it and return an Object, keyed by the reference value.

```js
const toHash = (object, key) =>
  Array.prototype.reduce.call(
    object,
    (acc, data, index) => ((acc[!key ? index : data[key]] = data), acc),
    {}
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
toHash([4, 3, 2, 1]); // { 0: 4, 1: 3, 2: 2, 3: 1 }
toHash([{ a: 'label' }], 'a'); // { label: { a: 'label' } }
// A more in depth example:
let users = [{ id: 1, first: 'Jon' }, { id: 2, first: 'Joe' }, { id: 3, first: 'Moe' }];
let managers = [{ manager: 1, employees: [2, 3] }];
// We use function here because we want a bindable reference, but a closure referencing the hash would work, too.
managers.forEach(
  manager =>
    (manager.employees = manager.employees.map(function(id) {
      return this[id];
    }, toHash(users, 'id')))
);
managers; // [ { manager:1, employees: [ { id: 2, first: "Joe" }, { id: 3, first: "Moe" } ] } ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### union

Returns every element that exists in any of the two arrays once.

Create a `Set` with all values of `a` and `b` and convert to an array.

```js
const union = (a, b) => Array.from(new Set([...a, ...b]));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
union([1, 2, 3], [4, 3, 2]); // [1,2,3,4]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### unionBy

Returns every element that exists in any of the two arrays once, after applying the provided function to each array element of both.

Create a `Set` by applying all `fn` to all values of `a`.
Create a `Set` from `a` and all elements in `b` whose value, after applying `fn` does not match a value in the previously created set.
Return the last set converted to an array.

```js
const unionBy = (a, b, fn) => {
  const s = new Set(a.map(fn));
  return Array.from(new Set([...a, ...b.filter(x => !s.has(fn(x)))]));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
unionBy([2.1], [1.2, 2.3], Math.floor); // [2.1, 1.2]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### unionWith

Returns every element that exists in any of the two arrays once, using a provided comparator function.

Create a `Set` with all values of `a` and values in `b` for which the comparator finds no matches in `a`, using `Array.prototype.findIndex()`.

```js
const unionWith = (a, b, comp) =>
  Array.from(new Set([...a, ...b.filter(x => a.findIndex(y => comp(x, y)) === -1)]));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
unionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) => Math.round(a) === Math.round(b)); // [1, 1.2, 1.5, 3, 0, 3.9]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### uniqueElements

Returns all unique values of an array.

Use ES6 `Set` and the `...rest` operator to discard all duplicated values.

```js
const uniqueElements = arr => [...new Set(arr)];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
uniqueElements([1, 2, 2, 3, 4, 4, 5]); // [1, 2, 3, 4, 5]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### uniqueElementsBy

Returns all unique values of an array, based on a provided comparator function.

Use `Array.prototype.reduce()` and `Array.prototype.some()` for an array containing only the first unique occurence of each value, based on the comparator function, `fn`.
The comparator function takes two arguments: the values of the two elements being compared.

```js
const uniqueElementsBy = (arr, fn) =>
  arr.reduce((acc, v) => {
    if (!acc.some(x => fn(v, x))) acc.push(v);
    return acc;
  }, []);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
uniqueElementsBy(
  [
    { id: 0, value: 'a' },
    { id: 1, value: 'b' },
    { id: 2, value: 'c' },
    { id: 1, value: 'd' },
    { id: 0, value: 'e' }
  ],
  (a, b) => a.id == b.id
); // [ { id: 0, value: 'a' }, { id: 1, value: 'b' }, { id: 2, value: 'c' } ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### uniqueElementsByRight

Returns all unique values of an array, based on a provided comparator function.

Use `Array.prototype.reduce()` and `Array.prototype.some()` for an array containing only the last unique occurence of each value, based on the comparator function, `fn`.
The comparator function takes two arguments: the values of the two elements being compared.

```js
const uniqueElementsByRight = (arr, fn) =>
  arr.reduceRight((acc, v) => {
    if (!acc.some(x => fn(v, x))) acc.push(v);
    return acc;
  }, []);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
uniqueElementsByRight(
  [
    { id: 0, value: 'a' },
    { id: 1, value: 'b' },
    { id: 2, value: 'c' },
    { id: 1, value: 'd' },
    { id: 0, value: 'e' }
  ],
  (a, b) => a.id == b.id
); // [ { id: 0, value: 'e' }, { id: 1, value: 'd' }, { id: 2, value: 'c' } ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### uniqueSymmetricDifference

Returns the unique symmetric difference between two arrays, not containing duplicate values from either array.

Use `Array.prototype.filter()` and `Array.prototype.includes()` on each array to remove values contained in the other, then create a `Set` from the results, removing duplicate values.

```js
const uniqueSymmetricDifference = (a, b) => [
  ...new Set([...a.filter(v => !b.includes(v)), ...b.filter(v => !a.includes(v))])
];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
uniqueSymmetricDifference([1, 2, 3], [1, 2, 4]); // [3, 4]
uniqueSymmetricDifference([1, 2, 2], [1, 3, 1]); // [2, 3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### unzip

Creates an array of arrays, ungrouping the elements in an array produced by [zip](#zip).

Use `Math.max.apply()` to get the longest subarray in the array, `Array.prototype.map()` to make each element an array.
Use `Array.prototype.reduce()` and `Array.prototype.forEach()` to map grouped values to individual arrays.

```js
const unzip = arr =>
  arr.reduce(
    (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc),
    Array.from({
      length: Math.max(...arr.map(x => x.length))
    }).map(x => [])
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
unzip([['a', 1, true], ['b', 2, false]]); // [['a', 'b'], [1, 2], [true, false]]
unzip([['a', 1, true], ['b', 2]]); // [['a', 'b'], [1, 2], [true]]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### unzipWith ![advanced](/advanced.svg)

Creates an array of elements, ungrouping the elements in an array produced by [zip](#zip) and applying the provided function.

Use `Math.max.apply()` to get the longest subarray in the array, `Array.prototype.map()` to make each element an array.
Use `Array.prototype.reduce()` and `Array.prototype.forEach()` to map grouped values to individual arrays.
Use `Array.prototype.map()` and the spread operator (`...`) to apply `fn` to each individual group of elements.

```js
const unzipWith = (arr, fn) =>
  arr
    .reduce(
      (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc),
      Array.from({
        length: Math.max(...arr.map(x => x.length))
      }).map(x => [])
    )
    .map(val => fn(...val));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
unzipWith([[1, 10, 100], [2, 20, 200]], (...args) => args.reduce((acc, v) => acc + v, 0)); // [3, 30, 300]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### without

Filters out the elements of an array, that have one of the specified values.

Use `Array.prototype.filter()` to create an array excluding(using `!Array.includes()`) all given values.

_(For a snippet that mutates the original array see [`pull`](#pull))_

```js
const without = (arr, ...args) => arr.filter(v => !args.includes(v));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
without([2, 1, 2, 3], 1, 2); // [3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### xProd

Creates a new array out of the two supplied by creating each possible pair from the arrays.

Use `Array.prototype.reduce()`, `Array.prototype.map()` and `Array.prototype.concat()` to produce every possible pair from the elements of the two arrays and save them in an array.

```js
const xProd = (a, b) => a.reduce((acc, x) => acc.concat(b.map(y => [x, y])), []);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
xProd([1, 2], ['a', 'b']); // [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### zip

Creates an array of elements, grouped based on the position in the original arrays.

Use `Math.max.apply()` to get the longest array in the arguments.
Creates an array with that length as return value and use `Array.from()` with a map-function to create an array of grouped elements.
If lengths of the argument-arrays vary, `undefined` is used where no value could be found.

```js
const zip = (...arrays) => {
  const maxLength = Math.max(...arrays.map(x => x.length));
  return Array.from({ length: maxLength }).map((_, i) => {
    return Array.from({ length: arrays.length }, (_, k) => arrays[k][i]);
  });
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
zip(['a', 'b'], [1, 2], [true, false]); // [['a', 1, true], ['b', 2, false]]
zip(['a'], [1, 2], [true, false]); // [['a', 1, true], [undefined, 2, false]]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### zipObject

Given an array of valid property identifiers and an array of values, return an object associating the properties to the values.

Since an object can have undefined values but not undefined property pointers, the array of properties is used to decide the structure of the resulting object using `Array.prototype.reduce()`.

```js
const zipObject = (props, values) =>
  props.reduce((obj, prop, index) => ((obj[prop] = values[index]), obj), {});
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
zipObject(['a', 'b', 'c'], [1, 2]); // {a: 1, b: 2, c: undefined}
zipObject(['a', 'b'], [1, 2, 3]); // {a: 1, b: 2}
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### zipWith ![advanced](/advanced.svg)

Creates an array of elements, grouped based on the position in the original arrays and using function as the last value to specify how grouped values should be combined.

Check if the last argument provided is a function.
Use `Math.max()` to get the longest array in the arguments.
Creates an array with that length as return value and use `Array.from()` with a map-function to create an array of grouped elements.
If lengths of the argument-arrays vary, `undefined` is used where no value could be found.
The function is invoked with the elements of each group `(...group)`.

```js
const zipWith = (...array) => {
  const fn = typeof array[array.length - 1] === 'function' ? array.pop() : undefined;
  return Array.from(
    { length: Math.max(...array.map(a => a.length)) },
    (_, i) => (fn ? fn(...array.map(a => a[i])) : array.map(a => a[i]))
  );
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
zipWith([1, 2], [10, 20], [100, 200], (a, b, c) => a + b + c); // [111,222]
zipWith(
  [1, 2, 3],
  [10, 20],
  [100, 200],
  (a, b, c) => (a != null ? a : 'a') + (b != null ? b : 'b') + (c != null ? c : 'c')
); // [111, 222, '3bc']
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)


---

## ğŸŒ Browser

### arrayToHtmlList

Converts the given array elements into `<li>` tags and appends them to the list of the given id.

Use `Array.prototype.map()`, `document.querySelector()`, and an anonymous inner closure to create a list of html tags.

```js
const arrayToHtmlList = (arr, listID) =>
  (el => (
    (el = document.querySelector('#' + listID)),
    (el.innerHTML += arr.map(item => `<li>${item}</li>`).join(''))
  ))();
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
arrayToHtmlList(['item 1', 'item 2'], 'myListID');
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### bottomVisible

Returns `true` if the bottom of the page is visible, `false` otherwise.

Use `scrollY`, `scrollHeight` and `clientHeight` to determine if the bottom of the page is visible.

```js
const bottomVisible = () =>
  document.documentElement.clientHeight + window.scrollY >=
  (document.documentElement.scrollHeight || document.documentElement.clientHeight);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
bottomVisible(); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### copyToClipboard ![advanced](/advanced.svg)

âš ï¸ **NOTICE:** The same functionality can be easily implemented by using the new asynchronous Clipboard API, which is still experimental but should be used in the future instead of this snippet. Find out more about it [here](https://github.com/w3c/clipboard-apis/blob/master/explainer.adoc#writing-to-the-clipboard).

Copy a string to the clipboard. 
Only works as a result of user action (i.e. inside a `click` event listener).

Create a new `<textarea>` element, fill it with the supplied data and add it to the HTML document.
Use `Selection.getRangeAt()`to store the selected range (if any).
Use `document.execCommand('copy')` to copy to the clipboard.
Remove the `<textarea>` element from the HTML document.
Finally, use `Selection().addRange()` to recover the original selected range (if any).

```js
const copyToClipboard = str => {
  const el = document.createElement('textarea');
  el.value = str;
  el.setAttribute('readonly', '');
  el.style.position = 'absolute';
  el.style.left = '-9999px';
  document.body.appendChild(el);
  const selected =
    document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false;
  el.select();
  document.execCommand('copy');
  document.body.removeChild(el);
  if (selected) {
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(selected);
  }
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
copyToClipboard('Lorem ipsum'); // 'Lorem ipsum' copied to clipboard.
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### counter ![advanced](/advanced.svg)

Creates a counter with the specified range, step and duration for the specified selector.

Check if `step` has the proper sign and change it accordingly.
Use `setInterval()` in combination with `Math.abs()` and `Math.floor()` to calculate the time between each new text draw.
Use `document.querySelector().innerHTML` to update the value of the selected element.
Omit the fourth parameter, `step`, to use a default step of `1`.
Omit the fifth parameter, `duration`, to use a default duration of `2000`ms.

```js
const counter = (selector, start, end, step = 1, duration = 2000) => {
  let current = start,
    _step = (end - start) * step < 0 ? -step : step,
    timer = setInterval(() => {
      current += _step;
      document.querySelector(selector).innerHTML = current;
      if (current >= end) document.querySelector(selector).innerHTML = end;
      if (current >= end) clearInterval(timer);
    }, Math.abs(Math.floor(duration / (end - start))));
  return timer;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
counter('#my-id', 1, 1000, 5, 2000); // Creates a 2-second timer for the element with id="my-id"
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### createElement

Creates an element from a string (without appending it to the document). 
If the given string contains multiple elements, only the first one will be returned.

Use `document.createElement()` to create a new element.
Set its `innerHTML` to the string supplied as the argument. 
Use `ParentNode.firstElementChild` to return the element version of the string.

```js
const createElement = str => {
  const el = document.createElement('div');
  el.innerHTML = str;
  return el.firstElementChild;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const el = createElement(
  `<div class="container">
    <p>Hello!</p>
  </div>`
);
console.log(el.className); // 'container'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### createEventHub ![advanced](/advanced.svg)

Creates a pub/sub ([publishâ€“subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)) event hub with `emit`, `on`, and `off` methods.

Use `Object.create(null)` to create an empty `hub` object that does not inherit properties from `Object.prototype`.
For `emit`, resolve the array of handlers based on the `event` argument and then run each one with `Array.prototype.forEach()` by passing in the data as an argument.
For `on`, create an array for the event if it does not yet exist, then use `Array.prototype.push()` to add the handler
to the array.
For `off`, use `Array.prototype.findIndex()` to find the index of the handler in the event array and remove it using `Array.prototype.splice()`.

```js
const createEventHub = () => ({
  hub: Object.create(null),
  emit(event, data) {
    (this.hub[event] || []).forEach(handler => handler(data));
  },
  on(event, handler) {
    if (!this.hub[event]) this.hub[event] = [];
    this.hub[event].push(handler);
  },
  off(event, handler) {
    const i = (this.hub[event] || []).findIndex(h => h === handler);
    if (i > -1) this.hub[event].splice(i, 1);
  }
});
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const handler = data => console.log(data);
const hub = createEventHub();
let increment = 0;

// Subscribe: listen for different types of events
hub.on('message', handler);
hub.on('message', () => console.log('Message event fired'));
hub.on('increment', () => increment++);

// Publish: emit events to invoke all handlers subscribed to them, passing the data to them as an argument
hub.emit('message', 'hello world'); // logs 'hello world' and 'Message event fired'
hub.emit('message', { hello: 'world' }); // logs the object and 'Message event fired'
hub.emit('increment'); // `increment` variable is now 1

// Unsubscribe: stop a specific handler from listening to the 'message' event
hub.off('message', handler);
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### currentURL

Returns the current URL.

Use `window.location.href` to get current URL.

```js
const currentURL = () => window.location.href;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
currentURL(); // 'https://google.com'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### detectDeviceType

Detects wether the website is being opened in a mobile device or a desktop/laptop.

Use a regular expression to test the `navigator.userAgent` property to figure out if the device is a mobile device or a desktop/laptop.

```js
const detectDeviceType = () =>
  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    ? 'Mobile'
    : 'Desktop';
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
detectDeviceType(); // "Mobile" or "Desktop"
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### elementContains

Returns `true` if the `parent` element contains the `child` element, `false` otherwise.

Check that `parent` is not the same element as `child`, use `parent.contains(child)` to check if the `parent` element contains the `child` element.

```js
const elementContains = (parent, child) => parent !== child && parent.contains(child);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
elementContains(document.querySelector('head'), document.querySelector('title')); // true
elementContains(document.querySelector('body'), document.querySelector('body')); // false
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### elementIsVisibleInViewport ![advanced](/advanced.svg)

Returns `true` if the element specified is visible in the viewport, `false` otherwise.

Use `Element.getBoundingClientRect()` and the `window.inner(Width|Height)` values
to determine if a given element is visible in the viewport.
Omit the second argument to determine if the element is entirely visible, or specify `true` to determine if
it is partially visible.

```js
const elementIsVisibleInViewport = (el, partiallyVisible = false) => {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return partiallyVisible
    ? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) &&
        ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))
    : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
// e.g. 100x100 viewport and a 10x10px element at position {top: -1, left: 0, bottom: 9, right: 10}
elementIsVisibleInViewport(el); // false - (not fully visible)
elementIsVisibleInViewport(el, true); // true - (partially visible)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### getImages

Fetches all images from within an element and puts them into an array

Use `Element.prototype.getElementsByTagName()` to fetch all `<img>` elements inside the provided element, `Array.prototype.map()` to map every `src` attribute of their respective `<img>` element, then create a `Set` to eliminate duplicates and return the array.

```js
const getImages = (el, includeDuplicates = false) => {
  const images = [...el.getElementsByTagName('img')].map(img => img.getAttribute('src'));
  return includeDuplicates ? images : [...new Set(images)];
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
getImages(document, true); // ['image1.jpg', 'image2.png', 'image1.png', '...']
getImages(document, false); // ['image1.jpg', 'image2.png', '...']
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### getScrollPosition

Returns the scroll position of the current page.

Use `pageXOffset` and `pageYOffset` if they are defined, otherwise `scrollLeft` and `scrollTop`.
You can omit `el` to use a default value of `window`.

```js
const getScrollPosition = (el = window) => ({
  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
});
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
getScrollPosition(); // {x: 0, y: 200}
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### getStyle

Returns the value of a CSS rule for the specified element.

Use `Window.getComputedStyle()` to get the value of the CSS rule for the specified element.

```js
const getStyle = (el, ruleName) => getComputedStyle(el)[ruleName];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
getStyle(document.querySelector('p'), 'font-size'); // '16px'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### hasClass

Returns `true` if the element has the specified class, `false` otherwise.

Use `element.classList.contains()` to check if the element has the specified class.

```js
const hasClass = (el, className) => el.classList.contains(className);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
hasClass(document.querySelector('p.special'), 'special'); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### hashBrowser ![advanced](/advanced.svg)

Creates a hash for a value using the [SHA-256](https://en.wikipedia.org/wiki/SHA-2) algorithm. Returns a promise.

Use the [SubtleCrypto](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto) API to create a hash for the given value.

```js
const hashBrowser = val =>
  crypto.subtle.digest('SHA-256', new TextEncoder('utf-8').encode(val)).then(h => {
    let hexes = [],
      view = new DataView(h);
    for (let i = 0; i < view.byteLength; i += 4)
      hexes.push(('00000000' + view.getUint32(i).toString(16)).slice(-8));
    return hexes.join('');
  });
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
hashBrowser(JSON.stringify({ a: 'a', b: [1, 2, 3, 4], foo: { c: 'bar' } })).then(console.log); // '04aa106279f5977f59f9067fa9712afc4aedc6f5862a8defc34552d8c7206393'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### hide

Hides all the elements specified.

Use `NodeList.prototype.forEach()` to apply `display: none` to each element specified.

```js
const hide = (...el) => [...el].forEach(e => (e.style.display = 'none'));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
hide(document.querySelectorAll('img')); // Hides all <img> elements on the page
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### httpsRedirect

Redirects the page to HTTPS if its currently in HTTP. Also, pressing the back button doesn't take it back to the HTTP page as its replaced in the history.

Use `location.protocol` to get the protocol currently being used. If it's not HTTPS, use `location.replace()` to replace the existing page with the HTTPS version of the page. Use `location.href` to get the full address, split it with `String.prototype.split()` and remove the protocol part of the URL.

```js
const httpsRedirect = () => {
  if (location.protocol !== 'https:') location.replace('https://' + location.href.split('//')[1]);
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
httpsRedirect(); // If you are on http://mydomain.com, you are redirected to https://mydomain.com
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### insertAfter

Inserts an HTML string after the end of the specified element.

Use `el.insertAdjacentHTML()` with a position of `'afterend'` to parse `htmlString` and insert it after the end of `el`.

```js
const insertAfter = (el, htmlString) => el.insertAdjacentHTML('afterend', htmlString);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
insertAfter(document.getElementById('myId'), '<p>after</p>'); // <div id="myId">...</div> <p>after</p>
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### insertBefore

Inserts an HTML string before the start of the specified element.

Use `el.insertAdjacentHTML()` with a position of `'beforebegin'` to parse `htmlString` and insert it before the start of `el`.

```js
const insertBefore = (el, htmlString) => el.insertAdjacentHTML('beforebegin', htmlString);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
insertBefore(document.getElementById('myId'), '<p>before</p>'); // <p>before</p> <div id="myId">...</div>
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isBrowserTabFocused

Returns `true` if the browser tab of the page is focused, `false` otherwise.

Use the `Document.hidden` property, introduced by the Page Visibility API to check if the browser tab of the page is visible or hidden.

```js
const isBrowserTabFocused = () => !document.hidden;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isBrowserTabFocused(); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### nodeListToArray

Converts a `NodeList` to an array.

Use spread operator inside new array to convert a `NodeList` to an array.

```js
const nodeListToArray = nodeList => [...nodeList];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
nodeListToArray(document.childNodes); // [ <!DOCTYPE html>, html ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### observeMutations ![advanced](/advanced.svg)

Returns a new MutationObserver and runs the provided callback for each mutation on the specified element.

Use a [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) to observe mutations on the given element.
Use `Array.prototype.forEach()` to run the callback for each mutation that is observed.
Omit the third argument, `options`, to use the default [options](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver#MutationObserverInit) (all `true`).

```js
const observeMutations = (element, callback, options) => {
  const observer = new MutationObserver(mutations => mutations.forEach(m => callback(m)));
  observer.observe(
    element,
    Object.assign(
      {
        childList: true,
        attributes: true,
        attributeOldValue: true,
        characterData: true,
        characterDataOldValue: true,
        subtree: true
      },
      options
    )
  );
  return observer;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const obs = observeMutations(document, console.log); // Logs all mutations that happen on the page
obs.disconnect(); // Disconnects the observer and stops logging mutations on the page
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### off

Removes an event listener from an element.

Use `EventTarget.removeEventListener()` to remove an event listener from an element. 
Omit the fourth argument `opts` to use `false` or specify it based on the options used when the event listener was added.

```js
const off = (el, evt, fn, opts = false) => el.removeEventListener(evt, fn, opts);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const fn = () => console.log('!');
document.body.addEventListener('click', fn);
off(document.body, 'click', fn); // no longer logs '!' upon clicking on the page
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### on

Adds an event listener to an element with the ability to use event delegation.

Use `EventTarget.addEventListener()` to add an event listener to an element. If there is a `target` property supplied to the options object, ensure the event target matches the target specified and then invoke the callback by supplying the correct `this` context.
Returns a reference to the custom delegator function, in order to be possible to use with [`off`](#off).
Omit `opts` to default to non-delegation behavior and event bubbling.

```js
const on = (el, evt, fn, opts = {}) => {
  const delegatorFn = e => e.target.matches(opts.target) && fn.call(e.target, e);
  el.addEventListener(evt, opts.target ? delegatorFn : fn, opts.options || false);
  if (opts.target) return delegatorFn;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const fn = () => console.log('!');
on(document.body, 'click', fn); // logs '!' upon clicking the body
on(document.body, 'click', fn, { target: 'p' }); // logs '!' upon clicking a `p` element child of the body
on(document.body, 'click', fn, { options: true }); // use capturing instead of bubbling
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### onUserInputChange ![advanced](/advanced.svg)

Run the callback whenever the user input type changes (`mouse` or `touch`). Useful for enabling/disabling code depending on the input device. This process is dynamic and works with hybrid devices (e.g. touchscreen laptops).

Use two event listeners. Assume `mouse` input initially and bind a `touchstart` event listener to the document. 
On `touchstart`, add a `mousemove` event listener to listen for two consecutive `mousemove` events firing within 20ms, using `performance.now()`.
Run the callback with the input type as an argument in either of these situations.

```js
const onUserInputChange = callback => {
  let type = 'mouse',
    lastTime = 0;
  const mousemoveHandler = () => {
    const now = performance.now();
    if (now - lastTime < 20)
      (type = 'mouse'), callback(type), document.removeEventListener('mousemove', mousemoveHandler);
    lastTime = now;
  };
  document.addEventListener('touchstart', () => {
    if (type === 'touch') return;
    (type = 'touch'), callback(type), document.addEventListener('mousemove', mousemoveHandler);
  });
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
onUserInputChange(type => {
  console.log('The user is now using', type, 'as an input method.');
});
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### prefix

Returns the prefixed version (if necessary) of a CSS property that the browser supports.

Use `Array.prototype.findIndex()` on an array of vendor prefix strings to test if `document.body` has one of them defined in its `CSSStyleDeclaration` object, otherwise return `null`.
Use `String.prototype.charAt()` and `String.prototype.toUpperCase()` to capitalize the property, which will be appended to the vendor prefix string.

```js
const prefix = prop => {
  const capitalizedProp = prop.charAt(0).toUpperCase() + prop.slice(1);
  const prefixes = ['', 'webkit', 'moz', 'ms', 'o'];
  const i = prefixes.findIndex(
    prefix => typeof document.body.style[prefix ? prefix + capitalizedProp : prop] !== 'undefined'
  );
  return i !== -1 ? (i === 0 ? prop : prefixes[i] + capitalizedProp) : null;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
prefix('appearance'); // 'appearance' on a supported browser, otherwise 'webkitAppearance', 'mozAppearance', 'msAppearance' or 'oAppearance'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### recordAnimationFrames

Invokes the provided callback on each animation frame.

Use recursion. 
Provided that `running` is `true`, continue invoking `window.requestAnimationFrame()` which invokes the provided callback. 
Return an object with two methods `start` and `stop` to allow manual control of the recording. 
Omit the second argument, `autoStart`, to implicitly call `start` when the function is invoked.

```js
const recordAnimationFrames = (callback, autoStart = true) => {
  let running = true,
    raf;
  const stop = () => {
    running = false;
    cancelAnimationFrame(raf);
  };
  const start = () => {
    running = true;
    run();
  };
  const run = () => {
    raf = requestAnimationFrame(() => {
      callback();
      if (running) run();
    });
  };
  if (autoStart) start();
  return { start, stop };
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const cb = () => console.log('Animation frame fired');
const recorder = recordAnimationFrames(cb); // logs 'Animation frame fired' on each animation frame
recorder.stop(); // stops logging
recorder.start(); // starts again
const recorder2 = recordAnimationFrames(cb, false); // `start` needs to be explicitly called to begin recording frames
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### redirect

Redirects to a specified URL.

Use `window.location.href` or `window.location.replace()` to redirect to `url`.
Pass a second argument to simulate a link click (`true` - default) or an HTTP redirect (`false`).

```js
const redirect = (url, asLink = true) =>
  asLink ? (window.location.href = url) : window.location.replace(url);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
redirect('https://google.com');
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### runAsync ![advanced](/advanced.svg)

Runs a function in a separate thread by using a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers), allowing long running functions to not block the UI.

Create a new `Worker` using a `Blob` object URL, the contents of which should be the stringified version of the supplied function.
Immediately post the return value of calling the function back.
Return a promise, listening for `onmessage` and `onerror` events and resolving the data posted back from the worker, or throwing an error.

```js
const runAsync = fn => {
  const worker = new Worker(
    URL.createObjectURL(new Blob([`postMessage((${fn})());`]), {
      type: 'application/javascript; charset=utf-8'
    })
  );
  return new Promise((res, rej) => {
    worker.onmessage = ({ data }) => {
      res(data), worker.terminate();
    };
    worker.onerror = err => {
      rej(err), worker.terminate();
    };
  });
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const longRunningFunction = () => {
  let result = 0;
  for (let i = 0; i < 1000; i++)
    for (let j = 0; j < 700; j++) for (let k = 0; k < 300; k++) result = result + i + j + k;

  return result;
};
/*
  NOTE: Since the function is running in a different context, closures are not supported.
  The function supplied to `runAsync` gets stringified, so everything becomes literal.
  All variables and functions must be defined inside.
*/
runAsync(longRunningFunction).then(console.log); // 209685000000
runAsync(() => 10 ** 3).then(console.log); // 1000
let outsideVariable = 50;
runAsync(() => typeof outsideVariable).then(console.log); // 'undefined'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### scrollToTop

Smooth-scrolls to the top of the page.

Get distance from top using `document.documentElement.scrollTop` or `document.body.scrollTop`.
Scroll by a fraction of the distance from the top. Use `window.requestAnimationFrame()` to animate the scrolling.

```js
const scrollToTop = () => {
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  }
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
scrollToTop();
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### setStyle

Sets the value of a CSS rule for the specified element.

Use `element.style` to set the value of the CSS rule for the specified element to `val`.

```js
const setStyle = (el, ruleName, val) => (el.style[ruleName] = val);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
setStyle(document.querySelector('p'), 'font-size', '20px'); // The first <p> element on the page will have a font-size of 20px
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### show

Shows all the elements specified.

Use the spread operator (`...`) and `Array.prototype.forEach()` to clear the `display` property for each element specified.

```js
const show = (...el) => [...el].forEach(e => (e.style.display = ''));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
show(...document.querySelectorAll('img')); // Shows all <img> elements on the page
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### smoothScroll

Smoothly scrolls the element on which it's called into the visible area of the browser window.

Use `.scrollIntoView` method to scroll the element. 
Pass `{ behavior: 'smooth' }` to `.scrollIntoView` so it scrolls smoothly.

```js
const smoothScroll = element =>
  document.querySelector(element).scrollIntoView({
    behavior: 'smooth'
  });
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
smoothScroll('#fooBar'); // scrolls smoothly to the element with the id fooBar
smoothScroll('.fooBar'); // scrolls smoothly to the first element with a class of fooBar
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### toggleClass

Toggle a class for an element.

Use `element.classList.toggle()` to toggle the specified class for the element.

```js
const toggleClass = (el, className) => el.classList.toggle(className);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
toggleClass(document.querySelector('p.special'), 'special'); // The paragraph will not have the 'special' class anymore
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### triggerEvent

Triggers a specific event on a given element, optionally passing custom data.

Use `new CustomEvent()` to create an event from the specified `eventType` and details.
Use `el.dispatchEvent()` to trigger the newly created event on the given element.
Omit the third argument, `detail`, if you do not want to pass custom data to the triggered event.

```js
const triggerEvent = (el, eventType, detail) =>
  el.dispatchEvent(new CustomEvent(eventType, { detail }));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
triggerEvent(document.getElementById('myId'), 'click');
triggerEvent(document.getElementById('myId'), 'click', { username: 'bob' });
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### UUIDGeneratorBrowser

Generates a UUID in a browser.

Use `crypto` API to generate a UUID, compliant with [RFC4122](https://www.ietf.org/rfc/rfc4122.txt) version 4.

```js
const UUIDGeneratorBrowser = () =>
  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
    (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
UUIDGeneratorBrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)


---

## â±ï¸ Date

### dayOfYear

Gets the day of the year from a `Date` object.

Use `new Date()` and `Date.prototype.getFullYear()` to get the first day of the year as a `Date` object, subtract it from the provided `date` and divide with the milliseconds in each day to get the result.
Use `Math.floor()` to appropriately round the resulting day count to an integer.

```js
const dayOfYear = date =>
  Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
dayOfYear(new Date()); // 272
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### formatDuration

Returns the human readable format of the given number of milliseconds.

Divide `ms` with the appropriate values to obtain the appropriate values for `day`, `hour`, `minute`, `second` and `millisecond`.
Use `Object.entries()` with `Array.prototype.filter()` to keep only non-zero values.
Use `Array.prototype.map()` to create the string for each value, pluralizing appropriately.
Use `String.prototype.join(', ')` to combine the values into a string.

```js
const formatDuration = ms => {
  if (ms < 0) ms = -ms;
  const time = {
    day: Math.floor(ms / 86400000),
    hour: Math.floor(ms / 3600000) % 24,
    minute: Math.floor(ms / 60000) % 60,
    second: Math.floor(ms / 1000) % 60,
    millisecond: Math.floor(ms) % 1000
  };
  return Object.entries(time)
    .filter(val => val[1] !== 0)
    .map(([key, val]) => `${val} ${key}${val !== 1 ? 's' : ''}`)
    .join(', ');
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
formatDuration(1001); // '1 second, 1 millisecond'
formatDuration(34325055574); // '397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### getColonTimeFromDate

Returns a string of the form `HH:MM:SS` from a `Date` object.

Use `Date.prototype.toTimeString()` and `String.prototype.slice()` to get the `HH:MM:SS` part of a given `Date` object.

```js
const getColonTimeFromDate = date => date.toTimeString().slice(0, 8);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
getColonTimeFromDate(new Date()); // "08:38:00"
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### getDaysDiffBetweenDates

Returns the difference (in days) between two dates.

Calculate the difference (in days) between two `Date` objects.

```js
const getDaysDiffBetweenDates = (dateInitial, dateFinal) =>
  (dateFinal - dateInitial) / (1000 * 3600 * 24);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
getDaysDiffBetweenDates(new Date('2017-12-13'), new Date('2017-12-22')); // 9
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### getMeridiemSuffixOfInteger

Converts an integer to a suffixed string, adding `am` or `pm` based on its value.

Use the modulo operator (`%`) and conditional checks to transform an integer to a stringified 12-hour format with meridiem suffix.

```js
const getMeridiemSuffixOfInteger = num =>
  num === 0 || num === 24
    ? 12 + 'am'
    : num === 12
      ? 12 + 'pm'
      : num < 12
        ? (num % 12) + 'am'
        : (num % 12) + 'pm';
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
getMeridiemSuffixOfInteger(0); // "12am"
getMeridiemSuffixOfInteger(11); // "11am"
getMeridiemSuffixOfInteger(13); // "1pm"
getMeridiemSuffixOfInteger(25); // "1pm"
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isAfterDate

Check if a date is after another date.

Use the greater than operator (`>`) to check if the first date comes after the second one.

```js
const isAfterDate = (dateA, dateB) => dateA > dateB;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isAfterDate(new Date(2010, 10, 21), new Date(2010, 10, 20)); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isBeforeDate

Check if a date is before another date.

Use the less than operator (`<`) to check if the first date comes before the second one.

```js
const isBeforeDate = (dateA, dateB) => dateA < dateB;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isBeforeDate(new Date(2010, 10, 20), new Date(2010, 10, 21)); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isSameDate

Check if a date is the same as another date.

Use `Date.prototype.toISOString()` and strict equality checking (`===`) to check if the first date is the same as the second one.

```js
const isSameDate = (dateA, dateB) => dateA.toISOString() === dateB.toISOString();
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isSameDate(new Date(2010, 10, 20), new Date(2010, 10, 20)); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### maxDate

Returns the maximum of the given dates.

Use `Math.max.apply()` to find the maximum date value, `new Date()` to convert it to a `Date` object.

```js
const maxDate = (...dates) => new Date(Math.max.apply(null, ...dates));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const array = [
  new Date(2017, 4, 13),
  new Date(2018, 2, 12),
  new Date(2016, 0, 10),
  new Date(2016, 0, 9)
];
maxDate(array); // 2018-03-11T22:00:00.000Z
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### minDate

Returns the minimum of the given dates.

Use `Math.min.apply()` to find the minimum date value, `new Date()` to convert it to a `Date` object.

```js
const minDate = (...dates) => new Date(Math.min.apply(null, ...dates));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const array = [
  new Date(2017, 4, 13),
  new Date(2018, 2, 12),
  new Date(2016, 0, 10),
  new Date(2016, 0, 9)
];
minDate(array); // 2016-01-08T22:00:00.000Z
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### tomorrow

Results in a string representation of tomorrow's date.

Use `new Date()` to get the current date, increment by one using `Date.getDate()` and set the value to the result using `Date.setDate()`. 
Use `Date.prototype.toISOString()` to return a string in `yyyy-mm-dd` format.

```js
const tomorrow = () => {
  let t = new Date();
  t.setDate(t.getDate() + 1);
  return t.toISOString().split('T')[0];
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
tomorrow(); // 2018-10-18 (if current date is 2018-10-18)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)


---

## ğŸ›ï¸ Function

### attempt

Attempts to invoke a function with the provided arguments, returning either the result or the caught error object.

Use a `try... catch` block to return either the result of the function or an appropriate error.

```js
const attempt = (fn, ...args) => {
  try {
    return fn(...args);
  } catch (e) {
    return e instanceof Error ? e : new Error(e);
  }
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
var elements = attempt(function(selector) {
  return document.querySelectorAll(selector);
}, '>_>');
if (elements instanceof Error) elements = []; // elements = []
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### bind

Creates a function that invokes `fn` with a given context, optionally adding any additional supplied parameters to the beginning of the arguments.

Return a `function` that uses `Function.prototype.apply()` to apply the given `context` to `fn`.
Use `Array.prototype.concat()` to prepend any additional supplied parameters to the arguments.

```js
const bind = (fn, context, ...boundArgs) => (...args) => fn.apply(context, [...boundArgs, ...args]);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
function greet(greeting, punctuation) {
  return greeting + ' ' + this.user + punctuation;
}
const freddy = { user: 'fred' };
const freddyBound = bind(greet, freddy);
console.log(freddyBound('hi', '!')); // 'hi fred!'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### bindKey

Creates a function that invokes the method at a given key of an object, optionally adding any additional supplied parameters to the beginning of the arguments.

Return a `function` that uses `Function.prototype.apply()` to bind `context[fn]` to `context`.
Use the spread operator (`...`) to prepend any additional supplied parameters to the arguments.

```js
const bindKey = (context, fn, ...boundArgs) => (...args) =>
  context[fn].apply(context, [...boundArgs, ...args]);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const freddy = {
  user: 'fred',
  greet: function(greeting, punctuation) {
    return greeting + ' ' + this.user + punctuation;
  }
};
const freddyBound = bindKey(freddy, 'greet');
console.log(freddyBound('hi', '!')); // 'hi fred!'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### chainAsync

Chains asynchronous functions.

Loop through an array of functions containing asynchronous events, calling `next` when each asynchronous event has completed.

```js
const chainAsync = fns => {
  let curr = 0;
  const last = fns[fns.length - 1];
  const next = () => {
    const fn = fns[curr++];
    fn === last ? fn() : fn(next);
  };
  next();
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
chainAsync([
  next => {
    console.log('0 seconds');
    setTimeout(next, 1000);
  },
  next => {
    console.log('1 second');
    setTimeout(next, 1000);
  },
  () => {
    console.log('2 second');
  }
]);
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### compose

Performs right-to-left function composition.

Use `Array.prototype.reduce()` to perform right-to-left function composition.
The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.

```js
const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const add5 = x => x + 5;
const multiply = (x, y) => x * y;
const multiplyAndAdd5 = compose(
  add5,
  multiply
);
multiplyAndAdd5(5, 2); // 15
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### composeRight

Performs left-to-right function composition.

Use `Array.prototype.reduce()` to perform left-to-right function composition.
The first (leftmost) function can accept one or more arguments; the remaining functions must be unary.

```js
const composeRight = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const add = (x, y) => x + y;
const square = x => x * x;
const addAndSquare = composeRight(add, square);
addAndSquare(1, 2); // 9
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### converge

Accepts a converging function and a list of branching functions and returns a function that applies each branching function to the arguments and the results of the branching functions are passed as arguments to the converging function.

Use `Array.prototype.map()` and `Function.prototype.apply()` to apply each function to the given arguments.
Use the spread operator (`...`) to call `coverger` with the results of all other functions.

```js
const converge = (converger, fns) => (...args) => converger(...fns.map(fn => fn.apply(null, args)));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const average = converge((a, b) => a / b, [
  arr => arr.reduce((a, v) => a + v, 0),
  arr => arr.length
]);
average([1, 2, 3, 4, 5, 6, 7]); // 4
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### curry

Curries a function.

Use recursion.
If the number of provided arguments (`args`) is sufficient, call the passed function `fn`.
Otherwise, return a curried function `fn` that expects the rest of the arguments.
If you want to curry a function that accepts a variable number of arguments (a variadic function, e.g. `Math.min()`), you can optionally pass the number of arguments to the second parameter `arity`.

```js
const curry = (fn, arity = fn.length, ...args) =>
  arity <= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
curry(Math.pow)(2)(10); // 1024
curry(Math.min, 3)(10)(50)(2); // 2
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### debounce

Creates a debounced function that delays invoking the provided function until at least `ms` milliseconds have elapsed since the last time it was invoked.

Each time the debounced function is invoked, clear the current pending timeout with `clearTimeout()` and use `setTimeout()` to create a new timeout that delays invoking the function until at least `ms` milliseconds has elapsed. Use `Function.prototype.apply()` to apply the `this` context to the function and provide the necessary arguments.
Omit the second argument, `ms`, to set the timeout at a default of 0 ms.

```js
const debounce = (fn, ms = 0) => {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), ms);
  };
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
window.addEventListener(
  'resize',
  debounce(() => {
    console.log(window.innerWidth);
    console.log(window.innerHeight);
  }, 250)
); // Will log the window dimensions at most every 250ms
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### defer

Defers invoking a function until the current call stack has cleared.

Use `setTimeout()` with a timeout of 1ms to add a new event to the browser event queue and allow the rendering engine to complete its work. Use the spread (`...`) operator to supply the function with an arbitrary number of arguments.

```js
const defer = (fn, ...args) => setTimeout(fn, 1, ...args);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
// Example A:
defer(console.log, 'a'), console.log('b'); // logs 'b' then 'a'

// Example B:
document.querySelector('#someElement').innerHTML = 'Hello';
longRunningFunction(); // Browser will not update the HTML until this has finished
defer(longRunningFunction); // Browser will update the HTML then run the function
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### delay

Invokes the provided function after `wait` milliseconds.

Use `setTimeout()` to delay execution of `fn`.
Use the spread (`...`) operator to supply the function with an arbitrary number of arguments.

```js
const delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
delay(
  function(text) {
    console.log(text);
  },
  1000,
  'later'
); // Logs 'later' after one second.
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### functionName

Logs the name of a function.

Use `console.debug()` and the `name` property of the passed method to log the method's name to the `debug` channel of the console.

```js
const functionName = fn => (console.debug(fn.name), fn);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
functionName(Math.max); // max (logged in debug channel of console)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### hz

Returns the number of times a function executed per second. 
`hz` is the unit for `hertz`, the unit of frequency defined as one cycle per second.

Use `performance.now()` to get the difference in milliseconds before and after the iteration loop to calculate the time elapsed executing the function `iterations` times. 
Return the number of cycles per second by converting milliseconds to seconds and dividing it by the time elapsed. 
Omit the second argument, `iterations`, to use the default of 100 iterations.

```js
const hz = (fn, iterations = 100) => {
  const before = performance.now();
  for (let i = 0; i < iterations; i++) fn();
  return (1000 * iterations) / (performance.now() - before);
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
// 10,000 element array
const numbers = Array(10000)
  .fill()
  .map((_, i) => i);

// Test functions with the same goal: sum up the elements in the array
const sumReduce = () => numbers.reduce((acc, n) => acc + n, 0);
const sumForLoop = () => {
  let sum = 0;
  for (let i = 0; i < numbers.length; i++) sum += numbers[i];
  return sum;
};

// `sumForLoop` is nearly 10 times faster
Math.round(hz(sumReduce)); // 572
Math.round(hz(sumForLoop)); // 4784
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### memoize ![advanced](/advanced.svg)

Returns the memoized (cached) function.

Create an empty cache by instantiating a new `Map` object.
Return a function which takes a single argument to be supplied to the memoized function by first checking if the function's output for that specific input value is already cached, or store and return it if not. The `function` keyword must be used in order to allow the memoized function to have its `this` context changed if necessary.
Allow access to the `cache` by setting it as a property on the returned function.

```js
const memoize = fn => {
  const cache = new Map();
  const cached = function(val) {
    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);
  };
  cached.cache = cache;
  return cached;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
// See the `anagrams` snippet.
const anagramsCached = memoize(anagrams);
anagramsCached('javascript'); // takes a long time
anagramsCached('javascript'); // returns virtually instantly since it's now cached
console.log(anagramsCached.cache); // The cached anagrams map
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### negate

Negates a predicate function.

Take a predicate function and apply the not operator (`!`) to it with its arguments.

```js
const negate = func => (...args) => !func(...args);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
[1, 2, 3, 4, 5, 6].filter(negate(n => n % 2 === 0)); // [ 1, 3, 5 ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### once

Ensures a function is called only once.

Utilizing a closure, use a flag, `called`, and set it to `true` once the function is called for the first time, preventing it from being called again. In order to allow the function to have its `this` context changed (such as in an event listener), the `function` keyword must be used, and the supplied function must have the context applied.
Allow the function to be supplied with an arbitrary number of arguments using the rest/spread (`...`) operator.

```js
const once = fn => {
  let called = false;
  return function(...args) {
    if (called) return;
    called = true;
    return fn.apply(this, args);
  };
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const startApp = function(event) {
  console.log(this, event); // document.body, MouseEvent
};
document.body.addEventListener('click', once(startApp)); // only runs `startApp` once upon click
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### partial

Creates a function that invokes `fn` with `partials` prepended to the arguments it receives.

Use the spread operator (`...`) to prepend `partials` to the list of arguments of `fn`.

```js
const partial = (fn, ...partials) => (...args) => fn(...partials, ...args);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const greet = (greeting, name) => greeting + ' ' + name + '!';
const greetHello = partial(greet, 'Hello');
greetHello('John'); // 'Hello John!'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### partialRight

Creates a function that invokes `fn` with `partials` appended to the arguments it receives.

Use the spread operator (`...`) to append `partials` to the list of arguments of `fn`.

```js
const partialRight = (fn, ...partials) => (...args) => fn(...args, ...partials);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const greet = (greeting, name) => greeting + ' ' + name + '!';
const greetJohn = partialRight(greet, 'John');
greetJohn('Hello'); // 'Hello John!'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### runPromisesInSeries

Runs an array of promises in series.

Use `Array.prototype.reduce()` to create a promise chain, where each promise returns the next promise when resolved.

```js
const runPromisesInSeries = ps => ps.reduce((p, next) => p.then(next), Promise.resolve());
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const delay = d => new Promise(r => setTimeout(r, d));
runPromisesInSeries([() => delay(1000), () => delay(2000)]); // Executes each promise sequentially, taking a total of 3 seconds to complete
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sleep

Delays the execution of an asynchronous function.

Delay executing part of an `async` function, by putting it to sleep, returning a `Promise`.

```js
const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
async function sleepyWork() {
  console.log("I'm going to sleep for 1 second.");
  await sleep(1000);
  console.log('I woke up after 1 second.');
}
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### throttle ![advanced](/advanced.svg)

Creates a throttled function that only invokes the provided function at most once per every `wait` milliseconds

Use `setTimeout()` and `clearTimeout()` to throttle the given method, `fn`.
Use `Function.prototype.apply()` to apply the `this` context to the function and provide the necessary `arguments`.
Use `Date.now()` to keep track of the last time the throttled function was invoked.
Omit the second argument, `wait`, to set the timeout at a default of 0 ms.

```js
const throttle = (fn, wait) => {
  let inThrottle, lastFn, lastTime;
  return function() {
    const context = this,
      args = arguments;
    if (!inThrottle) {
      fn.apply(context, args);
      lastTime = Date.now();
      inThrottle = true;
    } else {
      clearTimeout(lastFn);
      lastFn = setTimeout(function() {
        if (Date.now() - lastTime >= wait) {
          fn.apply(context, args);
          lastTime = Date.now();
        }
      }, Math.max(wait - (Date.now() - lastTime), 0));
    }
  };
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
window.addEventListener(
  'resize',
  throttle(function(evt) {
    console.log(window.innerWidth);
    console.log(window.innerHeight);
  }, 250)
); // Will log the window dimensions at most every 250ms
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### times

Iterates over a callback `n` times

Use `Function.call()` to call `fn` `n` times or until it returns `false`.
Omit the last argument, `context`, to use an `undefined` object (or the global object in non-strict mode).

```js
const times = (n, fn, context = undefined) => {
  let i = 0;
  while (fn.call(context, i) !== false && ++i < n) {}
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
var output = '';
times(5, i => (output += i));
console.log(output); // 01234
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### uncurry

Uncurries a function up to depth `n`.

Return a variadic function.
Use `Array.prototype.reduce()` on the provided arguments to call each subsequent curry level of the function.
If the `length` of the provided arguments is less than `n` throw an error.
Otherwise, call `fn` with the proper amount of arguments, using `Array.prototype.slice(0, n)`.
Omit the second argument, `n`, to uncurry up to depth `1`.

```js
const uncurry = (fn, n = 1) => (...args) => {
  const next = acc => args => args.reduce((x, y) => x(y), acc);
  if (n > args.length) throw new RangeError('Arguments too few!');
  return next(fn)(args.slice(0, n));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const add = x => y => z => x + y + z;
const uncurriedAdd = uncurry(add, 3);
uncurriedAdd(1, 2, 3); // 6
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### unfold

Builds an array, using an iterator function and an initial seed value.

Use a `while` loop and `Array.prototype.push()` to call the function repeatedly until it returns `false`.
The iterator function accepts one argument (`seed`) and must always return an array with two elements ([`value`, `nextSeed`]) or `false` to terminate.

```js
const unfold = (fn, seed) => {
  let result = [],
    val = [null, seed];
  while ((val = fn(val[1]))) result.push(val[0]);
  return result;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
var f = n => (n > 50 ? false : [-n, n + 10]);
unfold(f, 10); // [-10, -20, -30, -40, -50]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### when

Tests a value, `x`, against a predicate function. If `true`, return `fn(x)`. Else, return `x`. 

Return a function expecting a single value, `x`, that returns the appropriate value based on `pred`.

```js
const when = (pred, whenTrue) => x => (pred(x) ? whenTrue(x) : x);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const doubleEvenNumbers = when(x => x % 2 === 0, x => x * 2);
doubleEvenNumbers(2); // 4
doubleEvenNumbers(1); // 1
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)


---

## â— Math

### approximatelyEqual

Checks if two numbers are approximately equal to each other.

Use `Math.abs()` to compare the absolute difference of the two values to `epsilon`.
Omit the third parameter, `epsilon`, to use a default value of `0.001`.

```js
const approximatelyEqual = (v1, v2, epsilon = 0.001) => Math.abs(v1 - v2) < epsilon;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
approximatelyEqual(Math.PI / 2.0, 1.5708); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### average

Returns the average of two or more numbers.

Use `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`, divide by the `length` of the array.

```js
const average = (...nums) => nums.reduce((acc, val) => acc + val, 0) / nums.length;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
average(...[1, 2, 3]); // 2
average(1, 2, 3); // 2
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### averageBy

Returns the average of an array, after mapping each element to a value using the provided function.

Use `Array.prototype.map()` to map each element to the value returned by `fn`, `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`, divide by the `length` of the array.

```js
const averageBy = (arr, fn) =>
  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => acc + val, 0) /
  arr.length;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
averageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 5
averageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 5
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### binomialCoefficient

Evaluates the binomial coefficient of two integers `n` and `k`.

Use `Number.isNaN()` to check if any of the two values is `NaN`.
Check if `k` is less than `0`, greater than or equal to `n`, equal to `1` or `n - 1` and return the appropriate result.
Check if `n - k` is less than `k` and switch their values accordingly.
Loop from `2` through `k` and calculate the binomial coefficient.
Use `Math.round()` to account for rounding errors in the calculation.

```js
const binomialCoefficient = (n, k) => {
  if (Number.isNaN(n) || Number.isNaN(k)) return NaN;
  if (k < 0 || k > n) return 0;
  if (k === 0 || k === n) return 1;
  if (k === 1 || k === n - 1) return n;
  if (n - k < k) k = n - k;
  let res = n;
  for (let j = 2; j <= k; j++) res *= (n - j + 1) / j;
  return Math.round(res);
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
binomialCoefficient(8, 2); // 28
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### clampNumber

Clamps `num` within the inclusive range specified by the boundary values `a` and `b`.

If `num` falls within the range, return `num`.
Otherwise, return the nearest number in the range.

```js
const clampNumber = (num, a, b) => Math.max(Math.min(num, Math.max(a, b)), Math.min(a, b));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
clampNumber(2, 3, 5); // 3
clampNumber(1, -1, -5); // -1
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### degreesToRads

Converts an angle from degrees to radians.

Use `Math.PI` and the degree to radian formula to convert the angle from degrees to radians.

```js
const degreesToRads = deg => (deg * Math.PI) / 180.0;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
degreesToRads(90.0); // ~1.5708
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### digitize

Converts a number to an array of digits.

Convert the number to a string, using the spread operator (`...`) to build an array.
Use `Array.prototype.map()` and `parseInt()` to transform each value to an integer.

```js
const digitize = n => [...`${n}`].map(i => parseInt(i));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
digitize(123); // [1, 2, 3]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### distance

Returns the distance between two points.

Use `Math.hypot()` to calculate the Euclidean distance between two points.

```js
const distance = (x0, y0, x1, y1) => Math.hypot(x1 - x0, y1 - y0);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
distance(1, 1, 2, 3); // 2.23606797749979
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### elo ![advanced](/advanced.svg)

Computes the new ratings between two or more opponents using the [Elo rating system](https://en.wikipedia.org/wiki/Elo_rating_system). It takes an array
of pre-ratings and returns an array containing post-ratings.
The array should be ordered from best performer to worst performer (winner -> loser).

Use the exponent `**` operator and math operators to compute the expected score (chance of winning).
of each opponent and compute the new rating for each.
Loop through the ratings, using each permutation to compute the post-Elo rating for each player in a pairwise fashion. 
Omit the second argument to use the default `kFactor` of 32.

```js
const elo = ([...ratings], kFactor = 32, selfRating) => {
  const [a, b] = ratings;
  const expectedScore = (self, opponent) => 1 / (1 + 10 ** ((opponent - self) / 400));
  const newRating = (rating, i) =>
    (selfRating || rating) + kFactor * (i - expectedScore(i ? a : b, i ? b : a));
  if (ratings.length === 2) return [newRating(a, 1), newRating(b, 0)];

  for (let i = 0, len = ratings.length; i < len; i++) {
    let j = i;
    while (j < len - 1) {
      j++;
      [ratings[i], ratings[j]] = elo([ratings[i], ratings[j]], kFactor);
    }
  }
  return ratings;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
// Standard 1v1s
elo([1200, 1200]); // [1216, 1184]
elo([1200, 1200], 64); // [1232, 1168]
// 4 player FFA, all same rank
elo([1200, 1200, 1200, 1200]).map(Math.round); // [1246, 1215, 1185, 1154]
/*
For teams, each rating can adjusted based on own team's average rating vs.
average rating of opposing team, with the score being added to their
own individual rating by supplying it as the third argument.
*/
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### factorial

Calculates the factorial of a number.

Use recursion.
If `n` is less than or equal to `1`, return `1`.
Otherwise, return the product of `n` and the factorial of `n - 1`.
Throws an exception if `n` is a negative number.

```js

const factorial = n =>
  n < 0
    ? (() => {
      throw new TypeError('Negative numbers are not allowed!');
    })()
    : n <= 1
      ? 1
      : n * factorial(n - 1);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
factorial(6); // 720
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### fibonacci

Generates an array, containing the Fibonacci sequence, up until the nth term.

Create an empty array of the specific length, initializing the first two values (`0` and `1`).
Use `Array.prototype.reduce()` to add values into the array, using the sum of the last two values, except for the first two.

```js
const fibonacci = n =>
  Array.from({ length: n }).reduce(
    (acc, val, i) => acc.concat(i > 1 ? acc[i - 1] + acc[i - 2] : i),
    []
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
fibonacci(6); // [0, 1, 1, 2, 3, 5]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### gcd

Calculates the greatest common divisor between two or more numbers/arrays.

The inner `_gcd` function uses recursion.
Base case is when `y` equals `0`. In this case, return `x`.
Otherwise, return the GCD of `y` and the remainder of the division `x/y`.

```js
const gcd = (...arr) => {
  const _gcd = (x, y) => (!y ? x : gcd(y, x % y));
  return [...arr].reduce((a, b) => _gcd(a, b));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
gcd(8, 36); // 4
gcd(...[12, 8, 32]); // 4
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### geometricProgression

Initializes an array containing the numbers in the specified range where `start` and `end` are inclusive and the ratio between two terms is `step`.
Returns an error if `step` equals `1`.

Use `Array.from()`, `Math.log()` and `Math.floor()` to create an array of the desired length, `Array.prototype.map()` to fill with the desired values in a range.
Omit the second argument, `start`, to use a default value of `1`.
Omit the third argument, `step`, to use a default value of `2`.

```js
const geometricProgression = (end, start = 1, step = 2) =>
  Array.from({ length: Math.floor(Math.log(end / start) / Math.log(step)) + 1 }).map(
    (v, i) => start * step ** i
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
geometricProgression(256); // [1, 2, 4, 8, 16, 32, 64, 128, 256]
geometricProgression(256, 3); // [3, 6, 12, 24, 48, 96, 192]
geometricProgression(256, 1, 4); // [1, 4, 16, 64, 256]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### hammingDistance

Calculates the Hamming distance between two values.

Use XOR operator (`^`) to find the bit difference between the two numbers, convert to a binary string using `toString(2)`.
Count and return the number of `1`s in the string, using `match(/1/g)`.

```js
const hammingDistance = (num1, num2) => ((num1 ^ num2).toString(2).match(/1/g) || '').length;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
hammingDistance(2, 3); // 1
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### inRange

Checks if the given number falls within the given range.

Use arithmetic comparison to check if the given number is in the specified range.
If the second parameter, `end`, is not specified, the range is considered to be from `0` to `start`.

```js
const inRange = (n, start, end = null) => {
  if (end && start > end) [end, start] = [start, end];
  return end == null ? n >= 0 && n < start : n >= start && n < end;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
inRange(3, 2, 5); // true
inRange(3, 4); // true
inRange(2, 3, 5); // false
inRange(3, 2); // false
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isDivisible

Checks if the first numeric argument is divisible by the second one.

Use the modulo operator (`%`) to check if the remainder is equal to `0`.

```js
const isDivisible = (dividend, divisor) => dividend % divisor === 0;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isDivisible(6, 3); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isEven

Returns `true` if the given number is even, `false` otherwise.

Checks whether a number is odd or even using the modulo (`%`) operator.
Returns `true` if the number is even, `false` if the number is odd.

```js
const isEven = num => num % 2 === 0;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isEven(3); // false
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isNegativeZero

Checks if the given value is equal to negative zero (`-0`).

Checks whether a passed value is equal to `0` and if `1` divided by the value equals `-Infinity`.

```js
const isNegativeZero = val => val === 0 && 1 / val === -Infinity;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isNegativeZero(-0); // true
isNegativeZero(0); // false
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isPrime

Checks if the provided integer is a prime number.

Check numbers from `2` to the square root of the given number.
Return `false` if any of them divides the given number, else return `true`, unless the number is less than `2`.

```js
const isPrime = num => {
  const boundary = Math.floor(Math.sqrt(num));
  for (var i = 2; i <= boundary; i++) if (num % i === 0) return false;
  return num >= 2;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isPrime(11); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### lcm

Returns the least common multiple of two or more numbers.

Use the greatest common divisor (GCD) formula and the fact that `lcm(x,y) = x * y / gcd(x,y)` to determine the least common multiple.
The GCD formula uses recursion.

```js
const lcm = (...arr) => {
  const gcd = (x, y) => (!y ? x : gcd(y, x % y));
  const _lcm = (x, y) => (x * y) / gcd(x, y);
  return [...arr].reduce((a, b) => _lcm(a, b));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
lcm(12, 7); // 84
lcm(...[1, 3, 4, 5]); // 60
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### luhnCheck ![advanced](/advanced.svg)

Implementation of the [Luhn Algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm) used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers etc.

Use `String.prototype.split('')`, `Array.prototype.reverse()` and `Array.prototype.map()` in combination with `parseInt()` to obtain an array of digits.
Use `Array.prototype.splice(0,1)` to obtain the last digit.
Use `Array.prototype.reduce()` to implement the Luhn Algorithm.
Return `true` if `sum` is divisible by `10`, `false` otherwise.


```js
const luhnCheck = num => {
  let arr = (num + '')
    .split('')
    .reverse()
    .map(x => parseInt(x));
  let lastDigit = arr.splice(0, 1)[0];
  let sum = arr.reduce((acc, val, i) => (i % 2 !== 0 ? acc + val : acc + ((val * 2) % 9) || 9), 0);
  sum += lastDigit;
  return sum % 10 === 0;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
luhnCheck('4485275742308327'); // true
luhnCheck(6011329933655299); //  false
luhnCheck(123456789); // false
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### maxBy

Returns the maximum value of an array, after mapping each element to a value using the provided function.

Use `Array.prototype.map()` to map each element to the value returned by `fn`, `Math.max()` to get the maximum value.

```js
const maxBy = (arr, fn) => Math.max(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
maxBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 8
maxBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 8
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### median

Returns the median of an array of numbers.

Find the middle of the array, use `Array.prototype.sort()` to sort the values.
Return the number at the midpoint if `length` is odd, otherwise the average of the two middle numbers.

```js
const median = arr => {
  const mid = Math.floor(arr.length / 2),
    nums = [...arr].sort((a, b) => a - b);
  return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
median([5, 6, 50, 1, -5]); // 5
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### midpoint

Calculates the midpoint between two pairs of (x,y) points.

Destructure the array to get `x1`, `y1`, `x2` and `y2`, calculate the midpoint for each dimension by dividing the sum of the two endpoints by `2`.

```js
const midpoint = ([x1, y1], [x2, y2]) => [(x1 + x2) / 2, (y1 + y2) / 2];
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
midpoint([2, 2], [4, 4]); // [3, 3]
midpoint([4, 4], [6, 6]); // [5, 5]
midpoint([1, 3], [2, 4]); // [1.5, 3.5]
```


</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### minBy

Returns the minimum value of an array, after mapping each element to a value using the provided function.

Use `Array.prototype.map()` to map each element to the value returned by `fn`, `Math.min()` to get the maximum value.

```js
const minBy = (arr, fn) => Math.min(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
minBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 2
minBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 2
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### percentile

Uses the percentile formula to calculate how many numbers in the given array are less or equal to the given value.

Use `Array.prototype.reduce()` to calculate how many numbers are below the value and how many are the same value and apply the percentile formula.

```js
const percentile = (arr, val) =>
  (100 * arr.reduce((acc, v) => acc + (v < val ? 1 : 0) + (v === val ? 0.5 : 0), 0)) / arr.length;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
percentile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6); // 55
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### powerset

Returns the powerset of a given array of numbers.

Use `Array.prototype.reduce()` combined with `Array.prototype.map()` to iterate over elements and combine into an array containing all combinations.

```js
const powerset = arr => arr.reduce((a, v) => a.concat(a.map(r => [v].concat(r))), [[]]);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
powerset([1, 2]); // [[], [1], [2], [2, 1]]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### primes

Generates primes up to a given number, using the Sieve of Eratosthenes.

Generate an array from `2` to the given number. Use `Array.prototype.filter()` to filter out the values divisible by any number from `2` to the square root of the provided number.

```js
const primes = num => {
  let arr = Array.from({ length: num - 1 }).map((x, i) => i + 2),
    sqroot = Math.floor(Math.sqrt(num)),
    numsTillSqroot = Array.from({ length: sqroot - 1 }).map((x, i) => i + 2);
  numsTillSqroot.forEach(x => (arr = arr.filter(y => y % x !== 0 || y === x)));
  return arr;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
primes(10); // [2,3,5,7]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### radsToDegrees

Converts an angle from radians to degrees.

Use `Math.PI` and the radian to degree formula to convert the angle from radians to degrees.

```js
const radsToDegrees = rad => (rad * 180.0) / Math.PI;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
radsToDegrees(Math.PI / 2); // 90
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### randomIntArrayInRange

Returns an array of n random integers in the specified range.

Use `Array.from()` to create an empty array of the specific length, `Math.random()` to generate a random number and map it to the desired range, using `Math.floor()` to make it an integer.

```js
const randomIntArrayInRange = (min, max, n = 1) =>
  Array.from({ length: n }, () => Math.floor(Math.random() * (max - min + 1)) + min);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
randomIntArrayInRange(12, 35, 10); // [ 34, 14, 27, 17, 30, 27, 20, 26, 21, 14 ]
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### randomIntegerInRange

Returns a random integer in the specified range.

Use `Math.random()` to generate a random number and map it to the desired range, using `Math.floor()` to make it an integer.

```js
const randomIntegerInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
randomIntegerInRange(0, 5); // 2
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### randomNumberInRange

Returns a random number in the specified range.

Use `Math.random()` to generate a random value, map it to the desired range using multiplication.

```js
const randomNumberInRange = (min, max) => Math.random() * (max - min) + min;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
randomNumberInRange(2, 10); // 6.0211363285087005
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### round

Rounds a number to a specified amount of digits.

Use `Math.round()` and template literals to round the number to the specified number of digits.
Omit the second argument, `decimals` to round to an integer.

```js
const round = (n, decimals = 0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
round(1.005, 2); // 1.01
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sdbm

Hashes the input string into a whole number.

Use `String.prototype.split('')` and `Array.prototype.reduce()` to create a hash of the input string, utilizing bit shifting.

```js
const sdbm = str => {
  let arr = str.split('');
  return arr.reduce(
    (hashCode, currentVal) =>
      (hashCode = currentVal.charCodeAt(0) + (hashCode << 6) + (hashCode << 16) - hashCode),
    0
  );
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sdbm('name'); // -3521204949
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### standardDeviation

Returns the standard deviation of an array of numbers.

Use `Array.prototype.reduce()` to calculate the mean, variance and the sum of the variance of the values, the variance of the values, then
determine the standard deviation.
You can omit the second argument to get the sample standard deviation or set it to `true` to get the population standard deviation.

```js
const standardDeviation = (arr, usePopulation = false) => {
  const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;
  return Math.sqrt(
    arr.reduce((acc, val) => acc.concat((val - mean) ** 2), []).reduce((acc, val) => acc + val, 0) /
      (arr.length - (usePopulation ? 0 : 1))
  );
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
standardDeviation([10, 2, 38, 23, 38, 23, 21]); // 13.284434142114991 (sample)
standardDeviation([10, 2, 38, 23, 38, 23, 21], true); // 12.29899614287479 (population)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sum

Returns the sum of two or more numbers/arrays.

Use `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`.

```js
const sum = (...arr) => [...arr].reduce((acc, val) => acc + val, 0);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sum(1, 2, 3, 4); // 10
sum(...[1, 2, 3, 4]); // 10
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sumBy

Returns the sum of an array, after mapping each element to a value using the provided function.

Use `Array.prototype.map()` to map each element to the value returned by `fn`, `Array.prototype.reduce()` to add each value to an accumulator, initialized with a value of `0`.

```js
const sumBy = (arr, fn) =>
  arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => acc + val, 0);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sumBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 20
sumBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 20
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### sumPower

Returns the sum of the powers of all the numbers from `start` to `end` (both inclusive).

Use `Array.prototype.fill()` to create an array of all the numbers in the target range, `Array.prototype.map()` and the exponent operator (`**`) to raise them to `power` and `Array.prototype.reduce()` to add them together.
Omit the second argument, `power`, to use a default power of `2`.
Omit the third argument, `start`, to use a default starting value of `1`.

```js
const sumPower = (end, power = 2, start = 1) =>
  Array(end + 1 - start)
    .fill(0)
    .map((x, i) => (i + start) ** power)
    .reduce((a, b) => a + b, 0);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
sumPower(10); // 385
sumPower(10, 3); // 3025
sumPower(10, 3, 5); // 2925
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### toSafeInteger

Converts a value to a safe integer.

Use `Math.max()` and `Math.min()` to find the closest safe value.
Use `Math.round()` to convert to an integer.

```js
const toSafeInteger = num =>
  Math.round(Math.max(Math.min(num, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
toSafeInteger('3.2'); // 3
toSafeInteger(Infinity); // 9007199254740991
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)


---

## ğŸ“¦ Node

### atob

Decodes a string of data which has been encoded using base-64 encoding.

Create a `Buffer` for the given string with base-64 encoding and use `Buffer.toString('binary')` to return the decoded string.

```js
const atob = str => Buffer.from(str, 'base64').toString('binary');
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
atob('Zm9vYmFy'); // 'foobar'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### btoa

Creates a base-64 encoded ASCII string from a String object in which each character in the string is treated as a byte of binary data.

Create a `Buffer` for the given string with binary encoding and use `Buffer.toString('base64')` to return the encoded string.

```js
const btoa = str => Buffer.from(str, 'binary').toString('base64');
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
btoa('foobar'); // 'Zm9vYmFy'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### colorize

Add special characters to text to print in color in the console (combined with `console.log()`).

Use template literals and special characters to add the appropriate color code to the string output.
For background colors, add a special character that resets the background color at the end of the string.

```js
const colorize = (...args) => ({
  black: `\x1b[30m${args.join(' ')}`,
  red: `\x1b[31m${args.join(' ')}`,
  green: `\x1b[32m${args.join(' ')}`,
  yellow: `\x1b[33m${args.join(' ')}`,
  blue: `\x1b[34m${args.join(' ')}`,
  magenta: `\x1b[35m${args.join(' ')}`,
  cyan: `\x1b[36m${args.join(' ')}`,
  white: `\x1b[37m${args.join(' ')}`,
  bgBlack: `\x1b[40m${args.join(' ')}\x1b[0m`,
  bgRed: `\x1b[41m${args.join(' ')}\x1b[0m`,
  bgGreen: `\x1b[42m${args.join(' ')}\x1b[0m`,
  bgYellow: `\x1b[43m${args.join(' ')}\x1b[0m`,
  bgBlue: `\x1b[44m${args.join(' ')}\x1b[0m`,
  bgMagenta: `\x1b[45m${args.join(' ')}\x1b[0m`,
  bgCyan: `\x1b[46m${args.join(' ')}\x1b[0m`,
  bgWhite: `\x1b[47m${args.join(' ')}\x1b[0m`
});
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
console.log(colorize('foo').red); // 'foo' (red letters)
console.log(colorize('foo', 'bar').bgBlue); // 'foo bar' (blue background)
console.log(colorize(colorize('foo').yellow, colorize('foo').green).bgWhite); // 'foo bar' (first word in yellow letters, second word in green letters, white background for both)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### createDirIfNotExists

Creates a directory, if it does not exist.

Use `fs.existsSync()` to check if the directory exists, `fs.mkdirSync()` to create it.

```js
const fs = require('fs');
const createDirIfNotExists = dir => (!fs.existsSync(dir) ? fs.mkdirSync(dir) : undefined);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
createDirIfNotExists('test'); // creates the directory 'test', if it doesn't exist
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### hasFlags

Check if the current process's arguments contain the specified flags.

Use `Array.prototype.every()` and `Array.prototype.includes()` to check if `process.argv` contains all the specified flags.
Use a regular expression to test if the specified flags are prefixed with `-` or `--` and prefix them accordingly.

```js
const hasFlags = (...flags) =>
  flags.every(flag => process.argv.includes(/^-{1,2}/.test(flag) ? flag : '--' + flag));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
// node myScript.js -s --test --cool=true
hasFlags('-s'); // true
hasFlags('--test', 'cool=true', '-s'); // true
hasFlags('special'); // false
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### hashNode

Creates a hash for a value using the [SHA-256](https://en.wikipedia.org/wiki/SHA-2) algorithm. Returns a promise.

Use `crypto` API to create a hash for the given value, `setTimeout` to prevent blocking on a long operation, and a `Promise` to give it a familiar interface.

```js
const crypto = require('crypto');
const hashNode = val =>
  new Promise(resolve =>
    setTimeout(
      () =>
        resolve(
          crypto
            .createHash('sha256')
            .update(val)
            .digest('hex')
        ),
      0
    )
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
hashNode(JSON.stringify({ a: 'a', b: [1, 2, 3, 4], foo: { c: 'bar' } })).then(console.log); // '04aa106279f5977f59f9067fa9712afc4aedc6f5862a8defc34552d8c7206393'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isDuplexStream

Checks if the given argument is a duplex (readable and writable) stream.

Check if the value is different from `null`, use `typeof` to check if a value is of type `object` and the `pipe` property is of type `function`.
Additionally check if the `typeof` the `_read`, `_write` and `_readableState`, `_writableState` properties are `function` and `object` respectively.

```js
const isDuplexStream = val =>
  val !== null &&
  typeof val === 'object' &&
  typeof val.pipe === 'function' &&
  typeof val._read === 'function' &&
  typeof val._readableState === 'object' &&
  typeof val._write === 'function' &&
  typeof val._writableState === 'object';
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const Stream = require('stream');
isDuplexStream(new Stream.Duplex()); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isReadableStream

Checks if the given argument is a readable stream.

Check if the value is different from `null`, use `typeof` to check if the value is of type `object` and the `pipe` property is of type `function`.
Additionally check if the `typeof` the `_read` and `_readableState` properties are `function` and `object` respectively.

```js
const isReadableStream = val =>
  val !== null &&
  typeof val === 'object' &&
  typeof val.pipe === 'function' &&
  typeof val._read === 'function' &&
  typeof val._readableState === 'object';
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const fs = require('fs');
isReadableStream(fs.createReadStream('test.txt')); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isStream

Checks if the given argument is a stream.

Check if the value is different from `null`, use `typeof` to check if the value is of type `object` and the `pipe` property is of type `function`.

```js
const isStream = val => val !== null && typeof val === 'object' && typeof val.pipe === 'function';
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const fs = require('fs');
isStream(fs.createReadStream('test.txt')); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isTravisCI

Checks if the current environment is [Travis CI](https://travis-ci.org/).

Checks if the current environment has the `TRAVIS` and `CI` environment variables ([reference](https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables)).

```js
const isTravisCI = () => 'TRAVIS' in process.env && 'CI' in process.env;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
isTravisCI(); // true (if code is running on Travis CI)
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### isWritableStream

Checks if the given argument is a writable stream.

Check if the value is different from `null`, use `typeof` to check if the value is of type `object` and the `pipe` property is of type `function`.
Additionally check if the `typeof` the `_write` and `_writableState` properties are `function` and `object` respectively.

```js
const isWritableStream = val =>
  val !== null &&
  typeof val === 'object' &&
  typeof val.pipe === 'function' &&
  typeof val._write === 'function' &&
  typeof val._writableState === 'object';
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const fs = require('fs');
isWritableStream(fs.createWriteStream('test.txt')); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### JSONToFile

Writes a JSON object to a file.

Use `fs.writeFile()`, template literals and `JSON.stringify()` to write a `json` object to a `.json` file.

```js
const fs = require('fs');
const JSONToFile = (obj, filename) =>
  fs.writeFile(`${filename}.json`, JSON.stringify(obj, null, 2));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
JSONToFile({ test: 'is passed' }, 'testJsonFile'); // writes the object to 'testJsonFile.json'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### readFileLines

Returns an array of lines from the specified file.

Use `readFileSync` function in `fs` node package to create a `Buffer` from a file.
convert buffer to string using `toString(encoding)` function.
creating an array from contents of file by `split`ing file content line by line (each `\n`).

```js
const fs = require('fs');
const readFileLines = filename =>
  fs
    .readFileSync(filename)
    .toString('UTF8')
    .split('\n');
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
/*
contents of test.txt :
  line1
  line2
  line3
  ___________________________
*/
let arr = readFileLines('test.txt');
console.log(arr); // ['line1', 'line2', 'line3']
```


</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### untildify

Converts a tilde path to an absolute path.

Use `String.prototype.replace()` with a regular expression and `OS.homedir()` to replace the `~` in the start of the path with the home directory.

```js
const untildify = str => str.replace(/^~($|\/|\\)/, `${require('os').homedir()}$1`);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
untildify('~/node'); // '/Users/aUser/node'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### UUIDGeneratorNode

Generates a UUID in Node.JS.

Use `crypto` API to generate a UUID, compliant with [RFC4122](https://www.ietf.org/rfc/rfc4122.txt) version 4.

```js
const crypto = require('crypto');
const UUIDGeneratorNode = () =>
  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
    (c ^ (crypto.randomBytes(1)[0] & (15 >> (c / 4)))).toString(16)
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
UUIDGeneratorNode(); // '79c7c136-60ee-40a2-beb2-856f1feabefc'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)


---

## ğŸ—ƒï¸ Object

### bindAll

Binds methods of an object to the object itself, overwriting the existing method.

Use `Array.prototype.forEach()` to return a `function` that uses `Function.prototype.apply()` to apply the given context (`obj`) to `fn` for each function specified.

```js
const bindAll = (obj, ...fns) =>
  fns.forEach(
    fn => (
      (f = obj[fn]),
      (obj[fn] = function() {
        return f.apply(obj);
      })
    )
  );
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
var view = {
  label: 'docs',
  click: function() {
    console.log('clicked ' + this.label);
  }
};
bindAll(view, 'click');
jQuery(element).on('click', view.click); // Logs 'clicked docs' when clicked.
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### deepClone

Creates a deep clone of an object.

Use recursion.
Use `Object.assign()` and an empty object (`{}`) to create a shallow clone of the original.
Use `Object.keys()` and `Array.prototype.forEach()` to determine which key-value pairs need to be deep cloned.

```js
const deepClone = obj => {
  let clone = Object.assign({}, obj);
  Object.keys(clone).forEach(
    key => (clone[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key])
  );
  return Array.isArray(obj) && obj.length
    ? (clone.length = obj.length) && Array.from(clone)
    : Array.isArray(obj)
      ? Array.from(obj)
      : clone;
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const a = { foo: 'bar', obj: { a: 1, b: 2 } };
const b = deepClone(a); // a !== b, a.obj !== b.obj
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### deepFreeze

Deep freezes an object.

Calls `Object.freeze(obj)` recursively on all unfrozen properties of passed object that are `instanceof` object.

```js
const deepFreeze = obj =>
  Object.keys(obj).forEach(
    prop =>
      !(obj[prop] instanceof Object) || Object.isFrozen(obj[prop]) ? null : deepFreeze(obj[prop])
  ) || Object.freeze(obj);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
'use strict';

const o = deepFreeze([1, [2, 3]]);

o[0] = 3; // not allowed
o[1][0] = 4; // not allowed as well
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### deepMapKeys ![advanced](/advanced.svg)

Deep maps an object keys.

Creates an object with the same values as the provided object and keys generated by running the provided function for each key.

Use `Object.keys(obj)` to iterate over the object's keys. 
Use `Array.prototype.reduce()` to create a new object with the same values and mapped keys using `fn`.

```js

const deepMapKeys = (obj, f) =>
  Array.isArray(obj)
    ? obj.map(val => deepMapKeys(val, f))
    : typeof obj === 'object'
      ? Object.keys(obj).reduce((acc, current) => {
        const val = obj[current];
        acc[f(current)] =
            val !== null && typeof val === 'object' ? deepMapKeys(val, f) : (acc[f(current)] = val);
        return acc;
      }, {})
      : obj;
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const obj = {
  foo: '1',
  nested: {
    child: {
      withArray: [
        {
          grandChild: ['hello']
        }
      ]
    }
  }
};
const upperKeysObj = deepMapKeys(obj, key => key.toUpperCase());
/*
{
  "FOO":"1",
  "NESTED":{
    "CHILD":{
      "WITHARRAY":[
        {
          "GRANDCHILD":[ 'hello' ]
        }
      ]
    }
  }
}
*/
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### defaults

Assigns default values for all properties in an object that are `undefined`.

Use `Object.assign()` to create a new empty object and copy the original one to maintain key order, use `Array.prototype.reverse()` and the spread operator `...` to combine the default values from left to right, finally use `obj` again to overwrite properties that originally had a value.

```js
const defaults = (obj, ...defs) => Object.assign({}, obj, ...defs.reverse(), obj);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
defaults({ a: 1 }, { b: 2 }, { b: 6 }, { a: 3 }); // { a: 1, b: 2 }
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### dig

Returns the target value in a nested JSON object, based on the given key.

Use the `in` operator to check if `target` exists in `obj`.
If found, return the value of `obj[target]`, otherwise use `Object.values(obj)` and `Array.prototype.reduce()` to recursively call `dig` on each nested object until the first matching key/value pair is found.

```js

const dig = (obj, target) =>
  target in obj
    ? obj[target]
    : Object.values(obj).reduce((acc, val) => {
      if (acc !== undefined) return acc;
      if (typeof val === 'object') return dig(val, target);
    }, undefined);
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
const data = {
  level1: {
    level2: {
      level3: 'some data'
    }
  }
};
dig(data, 'level3'); // 'some data'
dig(data, 'level4'); // undefined
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### equals ![advanced](/advanced.svg)

Performs a deep comparison between two values to determine if they are equivalent.

Check if the two values are identical, if they are both `Date` objects with the same time, using `Date.getTime()` or if they are both non-object values with an equivalent value (strict comparison).
Check if only one value is `null` or `undefined` or if their prototypes differ.
If none of the above conditions are met, use `Object.keys()` to check if both values have the same number of keys, then use `Array.prototype.every()` to check if every key in the first value exists in the second one and if they are equivalent by calling this method recursively.

```js
const equals = (a, b) => {
  if (a === b) return true;
  if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
  if (!a || !b || (typeof a !== 'object' && typeof b !== 'object')) return a === b;
  if (a === null || a === undefined || b === null || b === undefined) return false;
  if (a.prototype !== b.prototype) return false;
  let keys = Object.keys(a);
  if (keys.length !== Object.keys(b).length) return false;
  return keys.every(k => equals(a[k], b[k]));
};
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
equals({ a: [2, { e: 3 }], b: [4], c: 'foo' }, { a: [2, { e: 3 }], b: [4], c: 'foo' }); // true
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### findKey

Returns the first key that satisfies the provided testing function. Otherwise `undefined` is returned.

Use `Object.keys(obj)` to get all the properties of the object, `Array.prototype.find()` to test the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.

```js
const findKey = (obj, fn) => Object.keys(obj).find(key => fn(obj[key], key, obj));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
findKey(
  {
    barney: { age: 36, active: true },
    fred: { age: 40, active: false },
    pebbles: { age: 1, active: true }
  },
  o => o['active']
); // 'barney'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### findLastKey

Returns the last key that satisfies the provided testing function.
Otherwise `undefined` is returned.

Use `Object.keys(obj)` to get all the properties of the object, `Array.prototype.reverse()` to reverse their order and `Array.prototype.find()` to test the provided function for each key-value pair.
The callback receives three arguments - the value, the key and the object.

```js
const findLastKey = (obj, fn) =>
  Object.keys(obj)
    .reverse()
    .find(key => fn(obj[key], key, obj));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
findLastKey(
  {
    barney: { age: 36, active: true },
    fred: { age: 40, active: false },
    pebbles: { age: 1, active: true }
  },
  o => o['active']
); // 'pebbles'
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### flattenObject

Flatten an object with the paths for keys.

Use recursion.
Use `Object.keys(obj)` combined with `Array.prototype.reduce()` to convert every leaf node to a flattened path node.
If the value of a key is an object, the function calls itself with the appropriate `prefix` to create the path using `Object.assign()`.
Otherwise, it adds the appropriate prefixed key-value pair to the accumulator object.
You should always omit the second argument, `prefix`, unless you want every key to have a prefix.

```js
const flattenObject = (obj, prefix = '') =>
  Object.keys(obj).reduce((acc, k) => {
    const pre = prefix.length ? prefix + '.' : '';
    if (typeof obj[k] === 'object') Object.assign(acc, flattenObject(obj[k], pre + k));
    else acc[pre + k] = obj[k];
    return acc;
  }, {});
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
flattenObject({ a: { b: { c: 1 } }, d: 1 }); // { 'a.b.c': 1, d: 1 }
```

</details>

<br>[â¬† å›åˆ°é¡¶éƒ¨](#ç›®å½•)

### forOwn

Iterates over all own properties of an object, running a callback for each one.

Use `Object.keys(obj)` to get all the properties of the object, `Array.prototype.forEach()` to run the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.

```js
const forOwn = (obj, fn) => Object.keys(obj).forEach(key => fn(obj[key], key, obj));
```

<details>
<summary>ç¤ºä¾‹</summary>

```js
forOwn({ foo: '